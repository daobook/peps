# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR xinetzone <xinzone@outlook.com>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-31 09:39+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../pep-0518.txt
msgid "Author"
msgstr ""

#: ../../pep-0518.txt:5
msgid ""
"Brett Cannon <brett@python.org>, Nathaniel Smith <njs@pobox.com>, Donald "
"Stufft <donald@stufft.io>"
msgstr ""

#: ../../pep-0518.txt
msgid "BDFL-Delegate"
msgstr ""

#: ../../pep-0518.txt:8
msgid "Nick Coghlan"
msgstr ""

#: ../../pep-0518.txt
msgid "Discussions-To"
msgstr ""

#: ../../pep-0518.txt:9
msgid "distutils-sig@python.org"
msgstr ""

#: ../../pep-0518.txt
msgid "Status"
msgstr ""

#: ../../pep-0518.txt:10
msgid "Final"
msgstr ""

#: ../../pep-0518.txt
msgid "Type"
msgstr ""

#: ../../pep-0518.txt:11
msgid "Standards Track"
msgstr ""

#: ../../pep-0518.txt
msgid "Topic"
msgstr ""

#: ../../pep-0518.txt:12
msgid "Packaging"
msgstr ""

#: ../../pep-0518.txt
msgid "Created"
msgstr ""

#: ../../pep-0518.txt:14
msgid "10-May-2016"
msgstr ""

#: ../../pep-0518.txt
msgid "Post-History"
msgstr ""

#: ../../pep-0518.txt:15
msgid "10-May-2016, 11-May-2016, 13-May-2016"
msgstr ""

#: ../../pep-0518.txt
msgid "Resolution"
msgstr ""

#: ../../pep-0518.txt:18
msgid "https://mail.python.org/pipermail/distutils-sig/2016-May/028969.html"
msgstr ""

#: ../../pep-0518.txt:22
msgid "Abstract"
msgstr "摘要"

#: ../../pep-0518.txt:24
msgid ""
"This PEP specifies how Python software packages should specify what build"
" dependencies they have in order to execute their chosen build system. As"
" part of this specification, a new configuration file is introduced for "
"software packages to use to specify their build dependencies (with the "
"expectation that the same configuration file will be used for future "
"configuration details)."
msgstr ""
"这个 PEP 指定了 Python 软件包应该如何指定它们所拥有的构建依赖关系，以便执行所选择的构建系统。"
"作为该规范的一部分，为软件包引入了新的配置文件，用于指定它们的构建依赖关系（预期相同的配置文件将用于未来的配置细节）。"

#: ../../pep-0518.txt:33
msgid "Rationale"
msgstr "基本原理"

#: ../../pep-0518.txt:35
msgid ""
"When Python first developed its tooling for building distributions of "
"software for projects, distutils [#distutils]_ was the chosen solution. "
"As time went on, setuptools [#setuptools]_ gained popularity to add some "
"features on top of distutils. Both used the concept of a ``setup.py`` "
"file that project maintainers executed to build distributions of their "
"software (as well as users to install said distribution)."
msgstr ""
"当 Python 第一次开发用于构建项目软件发行版的工具时，distutils [#distutils]_ 是被选择的解决方案。"
"随着时间的推移，setuptools [#setuptools]_ 越来越受欢迎，它在 distutils 之上添加了一些功能。"
"两者都使用了 ``setup.py`` 文件的概念，项目维护者执行该文件来构建其软件的发行版（以及用户安装该发行版）。"

#: ../../pep-0518.txt:43
msgid ""
"Using an executable file to specify build requirements under distutils "
"isn't an issue as distutils is part of Python's standard library. Having "
"the build tool as part of Python means that a ``setup.py`` has no "
"external dependency that a project maintainer needs to worry about to "
"build a distribution of their project. There was no need to specify any "
"dependency information as the only dependency is Python."
msgstr ""
"使用可执行文件在 distutils 下指定构建需求不是问题，因为 distutils 是 Python 标准库的一部分。"
"将构建工具作为 Python 的一部分意味着 ``setup.py`` 没有项目维护者在构建项目发行版时需要担心的外部依赖项。"
"没有必要指定任何依赖项信息，因为唯一的依赖项就是 Python。"

#: ../../pep-0518.txt:50
msgid ""
"But when a project chooses to use setuptools, the use of an executable "
"file like ``setup.py`` becomes an issue. You can't execute a ``setup.py``"
" file without knowing its dependencies, but currently there is no "
"standard way to know what those dependencies are in an automated fashion "
"without executing the ``setup.py`` file where that information is stored."
" It's a catch-22 of a file not being runnable without knowing its own "
"contents which can't be known programmatically unless you run the file."
msgstr ""
"但是当项目选择使用 setuptools 时，像 ``setup.py`` 这样的可执行文件的使用就成了问题。"
"你不能在不知道它的依赖关系的情况下执行 ``setup.py`` 文件，但目前没有标准的方法来自动地知道这些依赖关系是什么，而不执行存储信息的 ``setup.py`` 文件。"
"这是进退两难的局面，文件如果不知道它自己的内容就不能运行，除非你运行文件，否则无法通过编程知道它的内容。"

#: ../../pep-0518.txt:59
msgid ""
"Setuptools tried to solve this with a ``setup_requires`` argument to its "
"``setup()`` function [#setup_args]_. This solution has a number of "
"issues, such as:"
msgstr ""
"Setuptools 试图用 ``setup_requires`` 参数来解决这个问题，它的 ``setup()`` 函数 [#setup_args]_。这个解决方案有很多问题，比如："

#: ../../pep-0518.txt:63
msgid ""
"No tooling (besides setuptools itself) can access this information "
"without executing the ``setup.py``, but ``setup.py`` can't be executed "
"without having these items installed."
msgstr ""
"没有任何工具（除了 setuptools 本身）可以在不执行 ``setup.py`` 的情况下访问这些信息，但是如果没有安装这些项，``setup.py`` 就不能执行。"

#: ../../pep-0518.txt:66
msgid ""
"While setuptools itself will install anything listed in this, they won't "
"be installed until *during* the execution of the ``setup()`` function, "
"which means that the only way to actually use anything added here is "
"through increasingly complex machinations that delay the import and usage"
" of these modules until later on in the execution of the ``setup()`` "
"function."
msgstr ""
"虽然 setuptools 本身将安装中列出这样的东西，他们不会被安装到执行期间 ``setup()`` 的函数，"
"这意味着实际使用任何添加的唯一途径是通过日益复杂的机制，推迟 import 和使用这些模块，直到后来的执行 ``setup()`` 函数。"

#: ../../pep-0518.txt:72
msgid ""
"This cannot include ``setuptools`` itself nor can it include a "
"replacement to ``setuptools``, which means that projects such as "
"``numpy.distutils`` are largely incapable of utilizing it and projects "
"cannot take advantage of newer setuptools features until their users "
"naturally upgrade the version of setuptools to a newer one."
msgstr ""
"这不能包括 ``setuptools`` 本身，也不能包括 ``setuptools`` 的替代品，"
"这意味着 ``numpy.distutils`` 等项目，在很大程度上无法利用它，项目不能利用更新的 ``setuptools`` 功能，"
"直到他们的用户自然地将 ``setuptools`` 版本升级到更新的版本。"

#: ../../pep-0518.txt:78
msgid ""
"The items listed in ``setup_requires`` get implicitly installed whenever "
"you execute the ``setup.py`` but one of the common ways that the "
"``setup.py`` is executed is via another tool, such as ``pip``, who is "
"already managing dependencies. This means that a command like ``pip "
"install spam`` might end up having both pip and setuptools downloading "
"and installing packages and end users needing to configure *both* tools "
"(and for ``setuptools`` without being in control of the invocation) to "
"change settings like which repository it installs from. It also means "
"that users need to be aware of the discovery rules for both tools, as one"
" may support different package formats or determine the latest version "
"differently."
msgstr ""
"当您执行 ``setup.py`` 时，``setup_requires`` 中列出的项目将隐式安装，"
"但是执行 ``setup.py`` 的常见方式之一是通过另一个工具，例如 ``pip``，它已经在管理依赖项。"
"这意味着像 ``pip install spam`` 这样的命令可能最终会让 ``pip`` 和 ``setuptools`` 同时下载和安装包，"
"最终用户需要配置这两个工具（对于 ``setuptools`` 来说，不需要控制调用）来更改设置，比如从哪个存储库安装。"
"这还意味着用户需要了解这两种工具的发现规则，因为工具可能支持不同的包格式，或者以不同的方式确定最新版本。"

#: ../../pep-0518.txt:91
msgid ""
"This has culminated in a situation where use of ``setup_requires`` is "
"rare, where projects tend to either simply copy and paste snippets "
"between ``setup.py`` files or they eschew it all together in favor of "
"simply documenting elsewhere what they expect the user to have manually "
"installed prior to attempting to build or install their project."
msgstr ""
"这种情况导致很少使用 ``setup_requires``，项目倾向于简单地在 ``setup.py`` 文件之间复制和粘贴代码片段，"
"或者在试图构建或安装他们的项目之前简单地在其他地方记录他们希望用户手动安装的内容。"

#: ../../pep-0518.txt:98
msgid ""
"All of this has led pip [#pip]_ to simply assume that setuptools is "
"necessary when executing a ``setup.py`` file. The problem with this, "
"though, is it doesn't scale if another project began to gain traction in "
"the community as setuptools has. It also prevents other projects from "
"gaining traction due to the friction required to use it with a project "
"when pip can't infer the fact that something other than setuptools is "
"required."
msgstr ""
"所有这些导致pip [#pip]_ 简单地假设在执行 ``setup.py`` 文件时 setuptools 是必要的。"
"但问题是，如果另一个项目开始像 setuptools 一样在社区中获得吸引力，它就无法扩展。"
"当 pip 无法推断除了 setuptools 之外还需要其他工具时，它还可以防止其他项目获得关注，因为在项目中使用它所需的摩擦。"

#: ../../pep-0518.txt:106
msgid ""
"This PEP attempts to rectify the situation by specifying a way to list "
"the minimal dependencies of the build system of a project in a "
"declarative fashion in a specific file. This allows a project to list "
"what build dependencies it has to go from e.g. source checkout to wheel, "
"while not falling into the catch-22 trap that a ``setup.py`` has where "
"tooling can't infer what a project needs to build itself. Implementing "
"this PEP will allow projects to specify what build system they depend on "
"upfront so that tools like pip can make sure that they are installed in "
"order to run the build system to build the project."
msgstr ""
"这个 PEP 试图通过指定一种方法在特定文件中以声明的方式列出项目构建系统的最小依赖项来纠正这种情况。"
"这允许项目列出从源代码签出到轮的构建依赖关系，而不会陷入 ``setup.py`` 所具有的 catch-22 陷阱，即工具无法推断项目需要自己构建什么。"
"实现这个 PEP 将允许项目预先指定它们依赖的构建系统，这样像 ``pip`` 这样的工具就可以确保它们被安装，以便运行构建系统来构建项目。"

#: ../../pep-0518.txt:116
msgid ""
"To provide more context and motivation for this PEP, think of the (rough)"
" steps required to produce a built artifact for a project:"
msgstr ""
"为了为这个 PEP 提供更多的上下文和动机，请考虑为项目生成构建工件所需的(粗略的)步骤："

#: ../../pep-0518.txt:119
msgid "The source checkout of the project."
msgstr "项目的源代码检出"

#: ../../pep-0518.txt:120
msgid "Installation of the build system."
msgstr "构建系统的安装。"

#: ../../pep-0518.txt:121
msgid "Execute the build system."
msgstr "执行构建系统。"

#: ../../pep-0518.txt:123
msgid ""
"This PEP covers step #2. :pep:`517` covers step #3, including how to have"
" the build system dynamically specify more dependencies that the build "
"system requires to perform its job. The purpose of this PEP though, is to"
" specify the minimal set of requirements for the build system to simply "
"begin execution."
msgstr ""
"这个 PEP 涵盖了第 2 步。:pep:`517` 涵盖了第 3 步，包括如何让构建系统动态地指定构建系统执行其工作所需的更多依赖项。"
"不过，这个 PEP 的目的是指定构建系统开始执行所需的最小需求集。"

#: ../../pep-0518.txt:131
msgid "Specification"
msgstr "规范"

#: ../../pep-0518.txt:134
msgid "File Format"
msgstr "文件格式"

#: ../../pep-0518.txt:136
msgid ""
"The build system dependencies will be stored in a file named "
"``pyproject.toml`` that is written in the TOML format [#toml]_."
msgstr ""
"构建系统依赖项将存储在以 TOML 格式 [#toml]_ 编写名为 ``pyproject.toml`` 的文件中。"

#: ../../pep-0518.txt:139
msgid ""
"This format was chosen as it is human-usable (unlike JSON [#json]_), it "
"is flexible enough (unlike configparser [#configparser]_), stems from a "
"standard (also unlike configparser [#configparser]_), and it is not "
"overly complex (unlike YAML [#yaml]_). The TOML format is already in use "
"by the Rust community as part of their Cargo package manager [#cargo]_ "
"and in private email stated they have been quite happy with their choice "
"of TOML. A more thorough discussion as to why various alternatives were "
"not chosen can be read in the `Other file formats`_ section. The authors "
"do realize, though, that choice of configuration file format is "
"ultimately subjective and a choice had to be made and the authors prefer "
"TOML for this situation."
msgstr ""
"选择这种格式是因为它是人类可用的(不像JSON [#json]_)，它足够灵活(不像 configparser [#configparser]_)，"
"源于一个标准(也不像 configparser [#configparser]_)，并且它不是太复杂(不像 YAML [#yaml]_)。"
"TOML 格式已经被 Rust 社区作为 Cargo 包管理器 [#cargo]_ 的一部分使用，并且在私人邮件中表示他们对选择 TOML 非常满意。"
"关于为什么没有选择各种替代方案的更彻底的讨论可以在 `Other file formats`_  一节中阅读。"
"不过，作者确实意识到，配置文件格式的选择最终是主观的，必须做出选择，对于这种情况，作者更倾向于 TOML。"

#: ../../pep-0518.txt:151
msgid ""
"Below we list the tables that tools are expected to recognize/respect. "
"Tables not specified in this PEP are reserved for future use by other "
"PEPs."
msgstr ""
"下面我们列出了工具应该认可/尊重的表格。本 PEP 中未指定的表将保留给其他 PEP 将来使用。"

#: ../../pep-0518.txt:156
msgid "build-system table"
msgstr "build-system 表"

#: ../../pep-0518.txt:158
msgid ""
"The ``[build-system]`` table is used to store build-related data. "
"Initially only one key of the table will be valid and is mandatory for "
"the table: ``requires``. This key must have a value of a list of strings "
"representing :pep:`508` dependencies required to execute the build system"
" (currently that means what dependencies are required to execute a "
"``setup.py`` file)."
msgstr ""
"``[build-system]`` 表用于存储与构建相关的数据。"
"最初，表中只有一个键是有效的，并且对于表来说是强制性的：``requires``。"
"该键必须具有字符串列表的值，该字符串列表表示执行构建系统所需的 :pep:`508` 依赖项（目前这意味着执行 ``setup.py`` 文件所需的依赖项）。"

#: ../../pep-0518.txt:165
msgid ""
"For the vast majority of Python projects that rely upon setuptools, the "
"``pyproject.toml`` file will be::"
msgstr ""
"对于绝大多数依赖于 setuptools 的 Python 项目来说，``pyproject.toml`` 将是::"

#: ../../pep-0518.txt:172
msgid ""
"Because the use of setuptools and wheel are so expansive in the community"
" at the moment, build tools are expected to use the example configuration"
" file above as their default semantics when a ``pyproject.toml`` file is "
"not present."
msgstr ""
"因为目前 setuptools 和 wheel 的使用在社区中非常广泛，"
"当 ``pyproject.toml`` 文件不存在时，构建工具将使用上面的示例配置文件作为默认语义。"

#: ../../pep-0518.txt:177
msgid ""
"Tools should not require the existence of the ``[build-system]`` table. A"
" ``pyproject.toml`` file may be used to store configuration details other"
" than build-related data and thus lack a ``[build-system]`` table "
"legitimately. If the file exists but is lacking the ``[build-system]`` "
"table then the default values as specified above should be used. If the "
"table is specified but is missing required fields then the tool should "
"consider it an error."
msgstr ""
"工具不应该要求存在 ``[build-system]`` 表。``pyproject.toml`` 文件可能用于存储与构建相关的数据以外的配置细节，因此合法地缺少 ``[build-system]`` 表。"
"如果文件存在，但是缺少 ``[build-system]`` 表，那么应该使用上面指定的默认值。如果指定了表，但缺少必需的字段，那么工具应该认为这是一个错误。"

#: ../../pep-0518.txt:187
msgid "tool table"
msgstr "tool 表"

#: ../../pep-0518.txt:189
msgid ""
"The ``[tool]`` table is where any tool related to your Python project, "
"not just build tools, can have users specify configuration data as long "
"as they use a sub-table within ``[tool]``, e.g. the `flit "
"<https://pypi.python.org/pypi/flit>`_ tool would store its configuration "
"in ``[tool.flit]``."
msgstr ""
"``[tool]`` 表是任何与你的 Python 项目相关的工具（不仅仅是构建工具）都可以让用户指定配置数据的地方，"
"只要他们使用 ``[tool]`` 中的子表，例如 `flit <https://pypi.python.org/pypi/flit>`_ 工具会将其配置存储在 ``[tool.flit]`` 中。"

#: ../../pep-0518.txt:195
msgid ""
"We need some mechanism to allocate names within the ``tool.*`` namespace,"
" to make sure that different projects don't attempt to use the same sub-"
"table and collide. Our rule is that a project can use the subtable "
"``tool.$NAME`` if, and only if, they own the entry for ``$NAME`` in the "
"Cheeseshop/PyPI."
msgstr ""
"需要一些机制来在 ``tool.*`` 命名空间中分配名称，以确保不同的项目不会试图使用相同的子表而发生冲突。"
"我们的规则是项目可以使用子表工具。当且仅当他们拥有 Cheeseshop/PyPI 中 ``$NAME`` 的条目时。"

#: ../../pep-0518.txt:202
msgid "JSON Schema"
msgstr "JSON 模式"

#: ../../pep-0518.txt:204
msgid ""
"To provide a type-specific representation of the resulting data from the "
"TOML file for illustrative purposes only, the following JSON Schema "
"[#jsonschema]_ would match the data format::"
msgstr ""
"为了从 TOML 文件中提供特定类型的结果数据表示，仅用于说明目的，以下 JSON 模式 [#jsonschema]_ 将匹配数据格式::"

#: ../../pep-0518.txt:238
msgid "Rejected Ideas"
msgstr "拒绝的想法"

#: ../../pep-0518.txt:241
msgid "A semantic version key"
msgstr "语义版本键"

#: ../../pep-0518.txt:243
msgid ""
"For future-proofing the structure of the configuration file, a "
"``semantics-version`` key was initially proposed. Defaulting to ``1``, "
"the idea was that if any semantics changes to previously defined keys or "
"tables occurred which were not backwards-compatible, then the "
"``semantics-version`` would be incremented to a new number."
msgstr ""
"为了保证配置文件的结构不受未来影响，最初提出了 ``semantics-version`` 键。"
"默认为 ``1``，其想法是，如果之前定义的键或表发生了任何语义更改，而这些更改不向后兼容，那么 ``semantics-version`` 将被增加为新数字。"

#: ../../pep-0518.txt:249
msgid ""
"In the end, though, it was decided that this was a premature "
"optimization. The expectation is that changes to what is pre-defined "
"semantically in the configuration file will be rather conservative. And "
"in the instances where a backwards-incompatible change would have "
"occurred, different names can be used for the new semantics to avoid "
"breaking older tools."
msgstr ""
"但最终，我们认为这是不成熟的优化。"
"我们期望对配置文件中预定义语义的更改相当保守。"
"在可能发生向后不兼容更改的情况下，可以使用不同的名称来表示新的语义，以避免破坏旧的工具。"

#: ../../pep-0518.txt:258
msgid "A more nested namespace"
msgstr "嵌套更多的命名空间"

#: ../../pep-0518.txt:260
msgid ""
"An earlier draft of this PEP had a top-level ``[package]`` table. The "
"idea was to impose some scoping for a semantics versioning scheme (see `A"
" semantic version key`_ for why that idea was rejected). With the need "
"for scoping removed, the point of having a top-level table became "
"superfluous."
msgstr ""
"这个 PEP 的早期草案有一个顶级的 ``[package]`` 表。"
"这个想法是为语义版本控制方案强加一些作用域(参见 `A semantic version key`_ 了解为什么这个想法被拒绝)。"
"随着范围需求的消除，拥有顶级表的意义变得多余。"

#: ../../pep-0518.txt:268
msgid "Other table names"
msgstr "其他表名称"

#: ../../pep-0518.txt:270
msgid ""
"Another name proposed for the ``[build-system]`` table was ``[build]``. "
"The alternative name is shorter, but doesn't convey as much of the "
"intention of what information is stored in the table. After a vote on the"
" distutils-sig mailing list, the current name won out."
msgstr ""
"为 ``[build-system]`` 表提议的另一个名称是 ``[build]``。"
"替代名称更短，但不能传达表中存储哪些信息的意图。在对 distutils-sig 邮件列表进行投票后，当前的名称胜出。"

#: ../../pep-0518.txt:277
msgid "Other file formats"
msgstr "其他文件格式"

#: ../../pep-0518.txt:279
msgid ""
"Several other file formats were put forward for consideration, all "
"rejected for various reasons. Key requirements were that the format be "
"editable by human beings and have an implementation that can be vendored "
"easily by projects. This outright excluded certain formats like XML which"
" are not friendly towards human beings and were never seriously "
"discussed."
msgstr ""
"曾提出其他几种文件格式供考虑，但均因各种原因被拒绝。"
"关键的要求是格式可以由人编辑，并且有一个可以由项目轻松提供的实现。这完全排除了 XML 等对人类不友好的格式，而且从未认真讨论过。"

#: ../../pep-0518.txt:287
msgid "Overview of file formats considered"
msgstr ""

#: ../../pep-0518.txt:289
msgid ""
"The key reasons for rejecting the other alternatives considered are "
"summarised in the following sections, while the full review (including "
"positive arguments in favour of TOML) can be found at [#file_formats]_."
msgstr ""

#: ../../pep-0518.txt:293
msgid ""
"TOML was ultimately selected as it provided all the features we were "
"interested in, while avoiding the downsides introduced by the "
"alternatives."
msgstr ""

#: ../../pep-0518.txt:298
msgid "Feature"
msgstr ""

#: ../../pep-0518.txt:298
msgid "TOML"
msgstr ""

#: ../../pep-0518.txt:298 ../../pep-0518.txt:347
msgid "YAML"
msgstr ""

#: ../../pep-0518.txt:298 ../../pep-0518.txt:326
msgid "JSON"
msgstr ""

#: ../../pep-0518.txt:298
msgid "CFG/INI"
msgstr ""

#: ../../pep-0518.txt:300
msgid "Well-defined"
msgstr ""

#: ../../pep-0518.txt:300 ../../pep-0518.txt:301 ../../pep-0518.txt:302
#: ../../pep-0518.txt:303 ../../pep-0518.txt:304 ../../pep-0518.txt:305
#: ../../pep-0518.txt:306 ../../pep-0518.txt:307
msgid "yes"
msgstr ""

#: ../../pep-0518.txt:301
msgid "Real data types"
msgstr ""

#: ../../pep-0518.txt:302
msgid "Reliable Unicode"
msgstr ""

#: ../../pep-0518.txt:303
msgid "Reliable comments"
msgstr ""

#: ../../pep-0518.txt:304
msgid "Easy for humans to edit"
msgstr ""

#: ../../pep-0518.txt:304 ../../pep-0518.txt:305
msgid "??"
msgstr ""

#: ../../pep-0518.txt:305
msgid "Easy for tools to edit"
msgstr ""

#: ../../pep-0518.txt:306
msgid "In standard library"
msgstr ""

#: ../../pep-0518.txt:307
msgid "Easy for pip to vendor"
msgstr ""

#: ../../pep-0518.txt:307
msgid "n/a"
msgstr ""

#: ../../pep-0518.txt:310
msgid ""
"(\"??\" in the table indicates items where most folks would be inclined "
"to answer \"yes\", but there turn out to be a lot of quirks and edge "
"cases that arise in practice due to either the lack of a clear "
"specification, or else the underlying file format specification being "
"surprisingly complicated)"
msgstr ""

#: ../../pep-0518.txt:316
msgid ""
"The ``pytoml`` TOML parser is ~300 lines of pure Python code, so being "
"outside the standard library didn't count heavily against it."
msgstr ""

#: ../../pep-0518.txt:320
msgid ""
"Python literals were also discussed as a potential format, but weren't "
"considered in the file format review (since they're not a common pre-"
"existing file format)."
msgstr ""

#: ../../pep-0518.txt:328
msgid ""
"The JSON format [#json]_ was initially considered but quickly rejected. "
"While great as a human-readable, string-based data exchange format, the "
"syntax does not lend itself to easy editing by a human being (e.g. the "
"syntax is more verbose than necessary while not allowing for comments)."
msgstr ""

#: ../../pep-0518.txt:334
msgid "An example JSON file for the proposed data would be::"
msgstr ""

#: ../../pep-0518.txt:349
msgid ""
"The YAML format [#yaml]_ was designed to be a superset of JSON [#json]_ "
"while being easier to work with by hand. There are three main issues with"
" YAML."
msgstr ""

#: ../../pep-0518.txt:353
msgid ""
"One is that the specification is large: 86 pages if printed on letter-"
"sized paper. That leaves the possibility that someone may use a feature "
"of YAML that works with one parser but not another. It has been suggested"
" to standardize on a subset, but that basically means creating a new "
"standard specific to this file which is not tractable long-term."
msgstr ""

#: ../../pep-0518.txt:360
msgid ""
"Two is that YAML itself is not safe by default. The specification allows "
"for the arbitrary execution of code which is best avoided when dealing "
"with configuration data.  It is of course possible to avoid this behavior"
" -- for example, PyYAML provides a ``safe_load`` operation -- but if any "
"tool carelessly uses ``load`` instead then they open themselves up to "
"arbitrary code execution. While this PEP is focused on the building of "
"projects which inherently involves code execution, other configuration "
"data such as project name and version number may end up in the same file "
"someday where arbitrary code execution is not desired."
msgstr ""

#: ../../pep-0518.txt:371
msgid ""
"And finally, the most popular Python implementation of YAML is PyYAML "
"[#pyyaml]_ which is a large project of a few thousand lines of code and "
"an optional C extension module. While in and of itself this isn't "
"necessarily an issue, this becomes more of a problem for projects like "
"pip where they would most likely need to vendor PyYAML as a dependency so"
" as to be fully self-contained (otherwise you end up with your install "
"tool needing an install tool to work). A proof-of-concept re-working of "
"PyYAML has been done to see how easy it would be to potentially vendor a "
"simpler version of the library which shows it is a possibility."
msgstr ""

#: ../../pep-0518.txt:382
msgid "An example YAML file is::"
msgstr ""

#: ../../pep-0518.txt:391
msgid "configparser"
msgstr ""

#: ../../pep-0518.txt:393
msgid ""
"An INI-style configuration file based on what configparser "
"[#configparser]_ accepts was considered. Unfortunately there is no "
"specification of what configparser accepts, leading to support skew "
"between versions. For instance, what ConfigParser in Python 2.7 accepts "
"is not the same as what configparser in Python 3 accepts. While one could"
" standardize on what Python 3 accepts and simply vendor the backport of "
"the configparser module, that does mean this PEP would have to codify "
"that the backport of configparser must be used by all project wishes to "
"consume the metadata specified by this PEP. This is overly restrictive "
"and could lead to confusion if someone is not aware of that a specific "
"version of configparser is expected."
msgstr ""

#: ../../pep-0518.txt:406
msgid "An example INI file is::"
msgstr ""

#: ../../pep-0518.txt:415
msgid "Python literals"
msgstr ""

#: ../../pep-0518.txt:417
msgid ""
"Someone proposed using Python literals as the configuration format. The "
"file would contain one dict at the top level, with the data all inside "
"that dict, with sections defined by the keys. All Python programmers "
"would be used to the format, there would implicitly be no third-party "
"dependency to read the configuration data, and it can be safe if parsed "
"by ``ast.literal_eval()`` [#ast_literal_eval]_. Python literals can be "
"identical to JSON, with the added benefit of supporting trailing commas "
"and comments. In addition, Python's richer data model may be useful for "
"some future configuration needs (e.g. non-string dict keys, floating "
"point vs. integer values)."
msgstr ""

#: ../../pep-0518.txt:428
msgid ""
"On the other hand, python literals are a Python-specific format, and it "
"is anticipated that these data may need to be read by packaging tools, "
"etc. that are not written in Python."
msgstr ""

#: ../../pep-0518.txt:432
msgid "An example Python literal file for the proposed data would be::"
msgstr ""

#: ../../pep-0518.txt:445
msgid "Sticking with ``setup.cfg``"
msgstr ""

#: ../../pep-0518.txt:447
msgid ""
"There are two issues with ``setup.cfg`` used by setuptools as a general "
"format. One is that they are ``.ini`` files which have issues as "
"mentioned in the configparser_ discussion above. The other is that the "
"schema for that file has never been rigorously defined and thus it's "
"unknown which format would be safe to use going forward without "
"potentially confusing setuptools installations."
msgstr ""

#: ../../pep-0518.txt:457
msgid "Other file names"
msgstr ""

#: ../../pep-0518.txt:459
msgid ""
"Several other file names were considered and rejected (although this is "
"very much a bikeshedding topic, and so the decision comes down to mostly "
"taste)."
msgstr ""

#: ../../pep-0518.txt:464
msgid "pysettings.toml"
msgstr ""

#: ../../pep-0518.txt:464
msgid "Most reasonable alternative."
msgstr ""

#: ../../pep-0518.txt:469
msgid "pypa.toml"
msgstr ""

#: ../../pep-0518.txt:467
msgid ""
"While it makes sense to reference the PyPA [#pypa]_, it is a somewhat "
"niche term. It's better to have the file name make sense without having "
"domain-specific knowledge."
msgstr ""

#: ../../pep-0518.txt:474
msgid "pybuild.toml"
msgstr ""

#: ../../pep-0518.txt:472
msgid ""
"From the restrictive perspective of this PEP this filename makes sense, "
"but if any non-build metadata ever gets added to the file then the name "
"ceases to make sense."
msgstr ""

#: ../../pep-0518.txt:477
msgid "pip.toml"
msgstr ""

#: ../../pep-0518.txt:477
msgid "Too tool-specific."
msgstr ""

#: ../../pep-0518.txt:480
msgid "meta.toml"
msgstr ""

#: ../../pep-0518.txt:480
msgid "Too generic; project may want to have its own metadata file."
msgstr ""

#: ../../pep-0518.txt:485
msgid "setup.toml"
msgstr ""

#: ../../pep-0518.txt:483
msgid ""
"While keeping with traditional thanks to ``setup.py``, it does not "
"necessarily match what the file may contain in the future (e.g. is "
"knowing the name of a project inherently part of its setup?)."
msgstr ""

#: ../../pep-0518.txt:488
msgid "pymeta.toml"
msgstr ""

#: ../../pep-0518.txt:488
msgid "Not obvious to newcomers to programming and/or Python."
msgstr ""

#: ../../pep-0518.txt:491
msgid "pypackage.toml & pypackaging.toml"
msgstr ""

#: ../../pep-0518.txt:491
msgid "Name conflation of what a \"package\" is (project versus namespace)."
msgstr ""

#: ../../pep-0518.txt:494
msgid "pydevelop.toml"
msgstr ""

#: ../../pep-0518.txt:494
msgid "The file may contain details not specific to development."
msgstr ""

#: ../../pep-0518.txt:497
msgid "pysource.toml"
msgstr ""

#: ../../pep-0518.txt:497
msgid "Not directly related to source code."
msgstr ""

#: ../../pep-0518.txt:500
msgid "pytools.toml"
msgstr ""

#: ../../pep-0518.txt:500
msgid "Misleading as the file is (currently) aimed at project management."
msgstr ""

#: ../../pep-0518.txt:504
msgid "dstufft.toml"
msgstr ""

#: ../../pep-0518.txt:503
msgid "Too person-specific. ;)"
msgstr ""

#: ../../pep-0518.txt:507
msgid "References"
msgstr ""

#: ../../pep-0518.txt:509
msgid ""
"distutils (https://docs.python.org/3/library/distutils.html#module-"
"distutils)"
msgstr ""

#: ../../pep-0518.txt:512
msgid "setuptools (https://pypi.python.org/pypi/setuptools)"
msgstr ""

#: ../../pep-0518.txt:515
msgid ""
"setuptools: New and Changed setup() Keywords "
"(http://pythonhosted.org/setuptools/setuptools.html#new-and-changed-"
"setup-keywords)"
msgstr ""

#: ../../pep-0518.txt:518
msgid "pip (https://pypi.python.org/pypi/pip)"
msgstr ""

#: ../../pep-0518.txt:521
msgid "wheel (https://pypi.python.org/pypi/wheel)"
msgstr ""

#: ../../pep-0518.txt:524
msgid "TOML (https://github.com/toml-lang/toml)"
msgstr ""

#: ../../pep-0518.txt:527
msgid "JSON (http://json.org/)"
msgstr ""

#: ../../pep-0518.txt:530
msgid "YAML (http://yaml.org/)"
msgstr ""

#: ../../pep-0518.txt:533
msgid ""
"configparser (https://docs.python.org/3/library/configparser.html#module-"
"configparser)"
msgstr ""

#: ../../pep-0518.txt:536
msgid "PyYAML (https://pypi.python.org/pypi/PyYAML)"
msgstr ""

#: ../../pep-0518.txt:539
msgid "PyPA (https://www.pypa.io)"
msgstr ""

#: ../../pep-0518.txt:542
msgid "Bazel (http://bazel.io/)"
msgstr ""

#: ../../pep-0518.txt:545
msgid ""
"``ast.literal_eval()`` "
"(https://docs.python.org/3/library/ast.html#ast.literal_eval)"
msgstr ""

#: ../../pep-0518.txt:548
msgid "Cargo, Rust's package manager (http://doc.crates.io/)"
msgstr ""

#: ../../pep-0518.txt:551
msgid "JSON Schema (http://json-schema.org/)"
msgstr ""

#: ../../pep-0518.txt:554
msgid ""
"Nathaniel J. Smith's file format review "
"(https://gist.github.com/njsmith/78f68204c5d969f8c8bc645ef77d4a8f)"
msgstr ""

#: ../../pep-0518.txt:559
msgid "Copyright"
msgstr ""

#: ../../pep-0518.txt:561
msgid "This document has been placed in the public domain."
msgstr ""

#~ msgid "PEP"
#~ msgstr ""

#~ msgid "518"
#~ msgstr ""

#~ msgid "Title"
#~ msgstr ""

#~ msgid "Specifying Minimum Build System Requirements for Python Projects"
#~ msgstr ""

#~ msgid "distutils-sig <distutils-sig at python.org>"
#~ msgstr ""

#~ msgid ""
#~ "This PEP covers step #2. PEP 517"
#~ " covers step #3, including how to "
#~ "have the build system dynamically "
#~ "specify more dependencies that the build"
#~ " system requires to perform its job."
#~ " The purpose of this PEP though, "
#~ "is to specify the minimal set of"
#~ " requirements for the build system to"
#~ " simply begin execution."
#~ msgstr ""

#~ msgid ""
#~ "The ``[build-system]`` table is used "
#~ "to store build-related data. Initially"
#~ " only one key of the table will"
#~ " be valid and is mandatory for "
#~ "the table: ``requires``. This key must"
#~ " have a value of a list of "
#~ "strings representing PEP 508 dependencies "
#~ "required to execute the build system "
#~ "(currently that means what dependencies "
#~ "are required to execute a ``setup.py``"
#~ " file)."
#~ msgstr ""

#~ msgid ""
#~ "Another name proposed for the "
#~ "``[build-system]`` table was ``[build]``. "
#~ "The alternative name is shorter, but "
#~ "doesn't convey as much of the "
#~ "intention of what information is store"
#~ " in the table. After a vote on"
#~ " the distutils-sig mailing list, the"
#~ " current name won out."
#~ msgstr ""

