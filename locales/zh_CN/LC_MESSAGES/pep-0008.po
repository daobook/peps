# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0008.txt
msgid "PEP"
msgstr ""

#: ../../pep-0008.txt:1
msgid "8"
msgstr ""

#: ../../pep-0008.txt
msgid "Title"
msgstr ""

#: ../../pep-0008.txt:2
msgid "Style Guide for Python Code"
msgstr "Python 代码的风格指南"

#: ../../pep-0008.txt
msgid "Author"
msgstr ""

#: ../../pep-0008.txt:5
msgid ""
"Guido van Rossum <guido@python.org>, Barry Warsaw <barry@python.org>, "
"Nick Coghlan <ncoghlan@gmail.com>"
msgstr ""

#: ../../pep-0008.txt
msgid "Status"
msgstr ""

#: ../../pep-0008.txt:8
msgid "Active"
msgstr ""

#: ../../pep-0008.txt
msgid "Type"
msgstr ""

#: ../../pep-0008.txt:9
msgid "Process"
msgstr ""

#: ../../pep-0008.txt
msgid "Created"
msgstr ""

#: ../../pep-0008.txt:11
msgid "05-Jul-2001"
msgstr ""

#: ../../pep-0008.txt
msgid "Post-History"
msgstr ""

#: ../../pep-0008.txt:12
msgid "05-Jul-2001, 01-Aug-2013"
msgstr ""

#: ../../pep-0008.txt:16
msgid "Introduction"
msgstr "介绍"

#: ../../pep-0008.txt:18
msgid ""
"This document gives coding conventions for the Python code comprising the"
" standard library in the main Python distribution.  Please see the "
"companion informational PEP describing style guidelines for the C code in"
" the C implementation of Python [1]_."
msgstr ""
"这份文件给出了构成 Python 主发行版中标准库的 Python 代码的编码规则。"
"请参阅与之配套的信息性 PEP，它描述了 Python 的 C 实现中 C 代码的风格指南 [1]_。"

#: ../../pep-0008.txt:23
msgid ""
"This document and PEP 257 (Docstring Conventions) were adapted from "
"Guido's original Python Style Guide essay, with some additions from "
"Barry's style guide [2]_."
msgstr ""
"本文档和 PEP 257（文档字符串公约）改编自 Guido 最初的 Python 风格指南文章，并从 Barry 的风格指南中补充了一些内容 [2]_。"

#: ../../pep-0008.txt:27
msgid ""
"This style guide evolves over time as additional conventions are "
"identified and past conventions are rendered obsolete by changes in the "
"language itself."
msgstr ""
"本风格指南随着时间的推移而发展，因为更多的惯例被确定，而过去的惯例因语言本身的变化而变得过时。"

#: ../../pep-0008.txt:31
msgid ""
"Many projects have their own coding style guidelines. In the event of any"
" conflicts, such project-specific guides take precedence for that "
"project."
msgstr ""
"许多项目都有自己的编码风格指南。在有任何冲突的情况下，这种项目特有的指南对该项目来说是优先的。"

#: ../../pep-0008.txt:36
msgid "A Foolish Consistency is the Hobgoblin of Little Minds"
msgstr "愚蠢的一致性是小脑袋里的恶棍"

#: ../../pep-0008.txt:38
msgid ""
"One of Guido's key insights is that code is read much more often than it "
"is written.  The guidelines provided here are intended to improve the "
"readability of code and make it consistent across the wide spectrum of "
"Python code.  As PEP 20 says, \"Readability counts\"."
msgstr ""
"Guido 的关键见解之一是，代码被阅读的次数远远多于它被写的次数。"
"这里提供的指南是为了提高代码的可读性，并使其在广泛的 Python 代码中保持一致。"
"正如 PEP 20 所说，“可读性是重要的”。"

#: ../../pep-0008.txt:43
msgid ""
"A style guide is about consistency.  Consistency with this style guide is"
" important.  Consistency within a project is more important. Consistency "
"within one module or function is the most important."
msgstr ""
"风格指南是关于一致性的。与本风格指南保持一致是很重要的。"
"一个项目中的一致性更为重要。一个模块或函数内的一致性是最重要的。"

#: ../../pep-0008.txt:47
msgid ""
"However, know when to be inconsistent -- sometimes style guide "
"recommendations just aren't applicable.  When in doubt, use your best "
"judgment.  Look at other examples and decide what looks best.  And don't "
"hesitate to ask!"
msgstr ""
"然而，要知道什么时候应该不一致 -- 有时风格指南的建议就是不适用。"
"当有疑问时，使用你的最佳判断。看看其他的例子，决定什么看起来最好。而且不要犹豫，要问！"

#: ../../pep-0008.txt:52
msgid ""
"In particular: do not break backwards compatibility just to comply with "
"this PEP!"
msgstr ""
"特别是：不要为了遵守这个 PEP 而破坏向后的兼容性！"

#: ../../pep-0008.txt:55
msgid "Some other good reasons to ignore a particular guideline:"
msgstr "其他一些忽略某项准则的好理由："

#: ../../pep-0008.txt:57
msgid ""
"When applying the guideline would make the code less readable, even for "
"someone who is used to reading code that follows this PEP."
msgstr ""
"当应用该准则时，会使代码的可读性降低，甚至对于习惯于阅读遵循该 PEP 的代码的人来说也是如此。"

#: ../../pep-0008.txt:60
msgid ""
"To be consistent with surrounding code that also breaks it (maybe for "
"historic reasons) -- although this is also an opportunity to clean up "
"someone else's mess (in true XP style)."
msgstr ""
"要与周围的代码保持一致，这些代码也会破坏它（也许是出于历史原因）-- 尽管这也是一个清理别人的烂摊子的机会（真正的 XP 风格）。"

#: ../../pep-0008.txt:64
msgid ""
"Because the code in question predates the introduction of the guideline "
"and there is no other reason to be modifying that code."
msgstr ""
"因为所涉及的代码是在准则出台之前的，没有其他理由要修改该代码。"

#: ../../pep-0008.txt:67
msgid ""
"When the code needs to remain compatible with older versions of Python "
"that don't support the feature recommended by the style guide."
msgstr ""
"当代码需要与不支持风格指南推荐的特性的旧版本的 Python 保持兼容时。"

#: ../../pep-0008.txt:72
msgid "Code Lay-out"
msgstr "代码布局"

#: ../../pep-0008.txt:75
msgid "Indentation"
msgstr "缩进"

#: ../../pep-0008.txt:77
msgid "Use 4 spaces per indentation level."
msgstr "每个缩进级别使用 4 个空格。"

#: ../../pep-0008.txt:79
msgid ""
"Continuation lines should align wrapped elements either vertically using "
"Python's implicit line joining inside parentheses, brackets and braces, "
"or using a *hanging indent* [#fn-hi]_.  When using a hanging indent the "
"following should be considered; there should be no arguments on the first"
" line and further indentation should be used to clearly distinguish "
"itself as a continuation line::"
msgstr ""
"续行应该使用 Python 的小括号、大括号和圆括号内的隐式连线，"
"或者使用 *悬空缩进* [#fn-hi]_，将包裹的元素垂直对齐。"
"当使用悬空缩进时，应该考虑以下情况；第一行不应该有参数，"
"应该使用进一步的缩进来明确区分自己是一个延续行 ::"

#: ../../pep-0008.txt:117
msgid "The 4-space rule is optional for continuation lines."
msgstr "4-空格规则对续行来说是可选的。"

#: ../../pep-0008.txt:119
msgid "Optional::"
msgstr "可选 ::"

#: ../../pep-0008.txt:128
msgid ""
"When the conditional part of an ``if``-statement is long enough to "
"require that it be written across multiple lines, it's worth noting that "
"the combination of a two character keyword (i.e. ``if``), plus a single "
"space, plus an opening parenthesis creates a natural 4-space indent for "
"the subsequent lines of the multiline conditional.  This can produce a "
"visual conflict with the indented suite of code nested inside the "
"``if``-statement, which would also naturally be indented to 4 spaces.  "
"This PEP takes no explicit position on how (or whether) to further "
"visually distinguish such conditional lines from the nested suite inside "
"the ``if``-statement. Acceptable options in this situation include, but "
"are not limited to::"
msgstr ""
"当 ``if`` 语句的条件部分长到需要跨行书写时，值得注意的是，"
"两个字符的关键字（即 ``if`` ），加上一个空格，再加上一个开头的小括号，"
"为多行条件的后续行创造了一个自然的 4 空格缩进。"
"这可能会与嵌套在 ``if`` 语句中的缩进代码产生视觉冲突，这些代码也会自然缩进到 4 个空格。"
"对于如何（或是否）进一步从视觉上区分这些条件行和 ``if`` 语句内的嵌套代码，"
"本 PEP 没有采取明确的立场。这种情况下可接受的选项包括，但不限于 ::"

#: ../../pep-0008.txt:156
msgid ""
"(Also see the discussion of whether to break before or after binary "
"operators below.)"
msgstr ""
"（也可参见下文关于在二进制运算符之前或之后断开的讨论）。"

#: ../../pep-0008.txt:159
msgid ""
"The closing brace/bracket/parenthesis on multiline constructs may either "
"line up under the first non-whitespace character of the last line of "
"list, as in::"
msgstr ""
"多行结构的结尾大括号/方括号/圆括号可以排在最后一行列表的第一个非空格字符下，如 ::"

#: ../../pep-0008.txt:172
msgid ""
"or it may be lined up under the first character of the line that starts "
"the multiline construct, as in::"
msgstr ""
"或者它可以排在开始多行结构的一行的第一个字符下面，如 ::"

#: ../../pep-0008.txt:185
msgid "Tabs or Spaces?"
msgstr "制表符或者空格键"

#: ../../pep-0008.txt:187
msgid "Spaces are the preferred indentation method."
msgstr "空格是首选的缩进方法。"

#: ../../pep-0008.txt:189
msgid ""
"Tabs should be used solely to remain consistent with code that is already"
" indented with tabs."
msgstr ""
"制表符的使用应该仅仅是为了与已经用制表符缩进的代码保持一致。"

#: ../../pep-0008.txt:192
msgid "Python disallows mixing tabs and spaces for indentation."
msgstr "Python 不允许将制表符和空格混合在一起进行缩进。"

#: ../../pep-0008.txt:196
msgid "Maximum Line Length"
msgstr "行的最大列数"

#: ../../pep-0008.txt:198
msgid "Limit all lines to a maximum of 79 characters."
msgstr "将所有行数的列数限制在最多 79 个字符。"

#: ../../pep-0008.txt:200
msgid ""
"For flowing long blocks of text with fewer structural restrictions "
"(docstrings or comments), the line length should be limited to 72 "
"characters."
msgstr ""
"对于结构限制较少的流动的长文本块（文档串或注释），行的列长应限制在 72 个字符。"

#: ../../pep-0008.txt:204
msgid ""
"Limiting the required editor window width makes it possible to have "
"several files open side by side, and works well when using code review "
"tools that present the two versions in adjacent columns."
msgstr ""
"限制所需的编辑器窗口宽度，使得几个文件并排打开成为可能，在使用将两个版本呈现在相邻列的代码审查工具时，效果很好。"

#: ../../pep-0008.txt:208
msgid ""
"The default wrapping in most tools disrupts the visual structure of the "
"code, making it more difficult to understand. The limits are chosen to "
"avoid wrapping in editors with the window width set to 80, even if the "
"tool places a marker glyph in the final column when wrapping lines. Some "
"web based tools may not offer dynamic line wrapping at all."
msgstr ""
"大多数工具中的默认包装破坏了代码的视觉结构，使其更加难以理解。"
"选择这些限制是为了避免在窗口宽度设置为 80 的编辑器中出现包装，"
"即使工具在包装行时在最后一列放置一个标记字形。"
"一些基于网络的工具可能根本就不提供动态换行。"

#: ../../pep-0008.txt:214
msgid ""
"Some teams strongly prefer a longer line length.  For code maintained "
"exclusively or primarily by a team that can reach agreement on this "
"issue, it is okay to increase the line length limit up to 99 characters, "
"provided that comments and docstrings are still wrapped at 72 characters."
msgstr ""
"有些团队强烈希望有一个较长的行。"
"对于完全或主要由一个团队维护的代码，如果能在这个问题上达成一致，"
"可以将行长限制增加到 99 个字符，但注释和文档字符串仍以 72 个字符包裹。"

#: ../../pep-0008.txt:220
msgid ""
"The Python standard library is conservative and requires limiting lines "
"to 79 characters (and docstrings/comments to 72)."
msgstr ""
"Python 标准库很保守，要求将行数限制在 79 个字符以内（文档串/注释为 72 个）。"

#: ../../pep-0008.txt:223
msgid ""
"The preferred way of wrapping long lines is by using Python's implied "
"line continuation inside parentheses, brackets and braces.  Long lines "
"can be broken over multiple lines by wrapping expressions in parentheses."
" These should be used in preference to using a backslash for line "
"continuation."
msgstr ""
"包裹长行的首选方法是在小括号、大括号和大括号内使用 Python 的隐含续行功能。"
"长行可以通过在小括号中包裹表达式而在多行中断开。"
"应该优先使用这些小括号，而不是使用反斜杠进行续行。"

#: ../../pep-0008.txt:229
msgid ""
"Backslashes may still be appropriate at times.  For example, long, "
"multiple ``with``-statements cannot use implicit continuation, so "
"backslashes are acceptable::"
msgstr ""
"反斜线在某些时候可能仍然是合适的。"
"例如，长的、多个的 ``with`` 语句不能使用隐式续行，所以反斜线是可以接受的 ::"

#: ../../pep-0008.txt:237
msgid ""
"(See the previous discussion on `multiline if-statements`_ for further "
"thoughts on the indentation of such multiline ``with``-statements.)"
msgstr ""
"（见前面关于 `多行 if 语句`_ 的讨论，以进一步了解这种多行 ``with`` 语句的缩进情况）"。

#: ../../pep-0008.txt:240
msgid "Another such case is with ``assert`` statements."
msgstr "另一种情况是 ``assert`` 语句。"

#: ../../pep-0008.txt:242
msgid "Make sure to indent the continued line appropriately."
msgstr "请确保适当缩进续行。"

#: ../../pep-0008.txt:245
msgid "Should a Line Break Before or After a Binary Operator?"
msgstr "二元运算符之前或之后应该断行吗？"

#: ../../pep-0008.txt:247
msgid ""
"For decades the recommended style was to break after binary operators. "
"But this can hurt readability in two ways: the operators tend to get "
"scattered across different columns on the screen, and each operator is "
"moved away from its operand and onto the previous line.  Here, the eye "
"has to do extra work to tell which items are added and which are "
"subtracted::"
msgstr ""
"几十年来，推荐的风格是在二进制运算符之后断开。"
"但这在两个方面会损害可读性：运算符往往会分散在屏幕的不同列中，"
"而且每个运算符都会远离其操作数而被移到前一行。"
"在这里，眼睛不得不做额外的工作来分辨哪些项目是加法，哪些是减法 ::"

#: ../../pep-0008.txt:262
msgid ""
"To solve this readability problem, mathematicians and their publishers "
"follow the opposite convention.  Donald Knuth explains the traditional "
"rule in his *Computers and Typesetting* series: \"Although formulas "
"within a paragraph always break after binary operations and relations, "
"displayed formulas always break before binary operations\" [3]_."
msgstr ""
"为了解决这个可读性问题，数学家和他们的出版商遵循相反的惯例。"
"Donald Knuth 在他的 *计算机和排版* 系列中解释了这一传统规则："
"“虽然一段内的公式总是在二进制运算和关系之后断开，但显示的公式总是在二进制运算之前断开” [3]_。"

#: ../../pep-0008.txt:268
msgid ""
"Following the tradition from mathematics usually results in more readable"
" code::"
msgstr ""
"遵循数学的传统，通常会产生更可读的代码 ::"

#: ../../pep-0008.txt:279
msgid ""
"In Python code, it is permissible to break before or after a binary "
"operator, as long as the convention is consistent locally.  For new code "
"Knuth's style is suggested."
msgstr ""
"在 Python 代码中，允许在二进制运算符之前或之后断开，只要该约定在本地是一致的。"
"对于新的代码，建议采用 Knuth 的风格。"

#: ../../pep-0008.txt:284
msgid "Blank Lines"
msgstr "空白行"

#: ../../pep-0008.txt:286
msgid "Surround top-level function and class definitions with two blank lines."
msgstr "用两行空行包围顶级函数和类的定义。"

#: ../../pep-0008.txt:289
msgid "Method definitions inside a class are surrounded by a single blank line."
msgstr "类内的方法定义被一个空行所包围。"

#: ../../pep-0008.txt:292
msgid ""
"Extra blank lines may be used (sparingly) to separate groups of related "
"functions.  Blank lines may be omitted between a bunch of related one-"
"liners (e.g. a set of dummy implementations)."
msgstr ""
"可以使用额外的空行（少用）来分隔相关功能组。"
"在一堆相关的单行字之间可以省略空行（例如，一组 dummy 的实现）。"

#: ../../pep-0008.txt:296
msgid "Use blank lines in functions, sparingly, to indicate logical sections."
msgstr "在函数中少用空行，以表示逻辑部分。"

#: ../../pep-0008.txt:298
msgid ""
"Python accepts the control-L (i.e. ^L) form feed character as whitespace;"
" Many tools treat these characters as page separators, so you may use "
"them to separate pages of related sections of your file. Note, some "
"editors and web-based code viewers may not recognize control-L as a form "
"feed and will show another glyph in its place."
msgstr ""
"Python接受 control-L（即 ^L）形式的进位字符作为空白；"
"许多工具将这些字符视为页面分隔符，所以你可以用它们来分隔文件中相关部分的页面。"
"注意，一些编辑器和基于网络的代码查看器可能不承认 control-L 是换页符，而会在其位置上显示另一个字形。"

#: ../../pep-0008.txt:305
msgid "Source File Encoding"
msgstr "源文件编码"

#: ../../pep-0008.txt:307
msgid ""
"Code in the core Python distribution should always use UTF-8, and should "
"not have an encoding declaration."
msgstr ""
"核心 Python 发行版中的代码应该始终使用 UTF-8，并且不应该有编码声明。"

#: ../../pep-0008.txt:310
msgid ""
"In the standard library, non-UTF-8 encodings should be used only for test"
" purposes. Use non-ASCII characters sparingly, preferably only to denote "
"places and human names. If using non-ASCII characters as data, avoid "
"noisy Unicode characters like z̯̯͡a̧͎̺l̡͓̫g̹̲o̡̼̘ and byte order marks."
msgstr ""
"在标准库中，非 UTF-8 编码应该只用于测试目的。"
"少用非 ASCII 字符，最好只用来表示地方和人名。"
"如果使用非 ASCII 字符作为数据，应避免像  z̯̯͡a̧͎̺l̡͓̫g̹̲o̡̼̘  和字节顺序标记这样的噪音 Unicode 字符。"

#: ../../pep-0008.txt:316
msgid ""
"All identifiers in the Python standard library MUST use ASCII-only "
"identifiers, and SHOULD use English words wherever feasible (in many "
"cases, abbreviations and technical terms are used which aren't English)."
msgstr ""
"Python 标准库中的所有标识符必须使用纯 ASCII 的标识符，"
"并且在可行的情况下应该使用英文单词（在很多情况下，使用的缩写和技术术语都不是英文）。"

#: ../../pep-0008.txt:321
msgid ""
"Open source projects with a global audience are encouraged to adopt a "
"similar policy."
msgstr ""
"鼓励拥有全球受众的开源项目采取类似的政策。"

#: ../../pep-0008.txt:325
msgid "Imports"
msgstr ""

#: ../../pep-0008.txt:327
msgid "Imports should usually be on separate lines::"
msgstr "进口通常应在单独的行中进行 ::"

#: ../../pep-0008.txt:339
msgid "It's okay to say this though::"
msgstr "虽然这样说也没关系 ::"

#: ../../pep-0008.txt:344
msgid ""
"Imports are always put at the top of the file, just after any module "
"comments and docstrings, and before module globals and constants."
msgstr ""
"import 总是放在文件的顶部，就在任何模块的注释和文档字符串说明之后，在模块全局和常量之前。"

#: ../../pep-0008.txt:347
msgid "Imports should be grouped in the following order:"
msgstr "import 应按以下顺序分组："

#: ../../pep-0008.txt:349
msgid "Standard library imports."
msgstr "标准库导入。"

#: ../../pep-0008.txt:350
msgid "Related third party imports."
msgstr "相关的第三方导入。"

#: ../../pep-0008.txt:351
msgid "Local application/library specific imports."
msgstr "本地应用程序/库的特定导入。"

#: ../../pep-0008.txt:353
msgid "You should put a blank line between each group of imports."
msgstr "你应该在每组 import 之间放一个空行。"

#: ../../pep-0008.txt:355
msgid ""
"Absolute imports are recommended, as they are usually more readable and "
"tend to be better behaved (or at least give better error messages) if the"
" import system is incorrectly configured (such as when a directory inside"
" a package ends up on ``sys.path``)::"
msgstr ""
"推荐使用绝对导入，因为它们通常更具可读性，"
"而且如果导入系统配置不正确（例如当包内的目录最终出现在 ``sys.path`` 上时），"
"往往表现得更好（或至少给出更好的错误信息） ::"

#: ../../pep-0008.txt:364
msgid ""
"However, explicit relative imports are an acceptable alternative to "
"absolute imports, especially when dealing with complex package layouts "
"where using absolute imports would be unnecessarily verbose::"
msgstr ""
"然而，明确的相对导入是绝对导入的一个可接受的替代方法，"
"特别是在处理复杂的包布局时，使用绝对导入会造成不必要的啰嗦 ::"

#: ../../pep-0008.txt:371
msgid ""
"Standard library code should avoid complex package layouts and always use"
" absolute imports."
msgstr ""
"标准库代码应避免复杂的包布局，并始终使用绝对导入。"

#: ../../pep-0008.txt:374
msgid ""
"When importing a class from a class-containing module, it's usually okay "
"to spell this::"
msgstr ""
"当从一个含类模块中导入一个类时，通常可以这样拼 ::"

#: ../../pep-0008.txt:380
msgid "If this spelling causes local name clashes, then spell them explicitly::"
msgstr "如果这种拼写方式导致本地名称冲突，那么就显式地拼写它们 ::"

#: ../../pep-0008.txt:385
msgid "and use \"myclass.MyClass\" and \"foo.bar.yourclass.YourClass\"."
msgstr "并使用 \"myclass.MyClass\" 和 \"foo.bar.yourclass.YourClass\"。"

#: ../../pep-0008.txt:387
msgid ""
"Wildcard imports (``from <module> import *``) should be avoided, as they "
"make it unclear which names are present in the namespace, confusing both "
"readers and many automated tools. There is one defensible use case for a "
"wildcard import, which is to republish an internal interface as part of a"
" public API (for example, overwriting a pure Python implementation of an "
"interface with the definitions from an optional accelerator module and "
"exactly which definitions will be overwritten isn't known in advance)."
msgstr ""
"应该避免使用通配符导入（``from <module> import *``），"
"因为它们使人不清楚哪些名字存在于名字空间中，使读者和许多自动工具都感到困惑。"
"通配符导入有一个合理的用例，那就是重新发布一个内部接口作为公共 API 的一部分"
"（例如，用一个可选的加速器模块的定义覆盖一个纯 Python 接口的实现，"
"究竟哪些定义会被覆盖并不事先知道）。"

#: ../../pep-0008.txt:396
msgid ""
"When republishing names this way, the guidelines below regarding public "
"and internal interfaces still apply."
msgstr ""
"当以这种方式重新发布名称时，下面关于公共和内部接口的准则仍然适用。"

#: ../../pep-0008.txt:400
msgid "Module Level Dunder Names"
msgstr "模块级的 Dunder 名称"

#: ../../pep-0008.txt:402
msgid ""
"Module level \"dunders\" (i.e. names with two leading and two trailing "
"underscores) such as ``__all__``, ``__author__``, ``__version__``, etc. "
"should be placed after the module docstring but before any import "
"statements *except* ``from __future__`` imports.  Python mandates that "
"future-imports must appear in the module before any other code except "
"docstrings::"
msgstr ""
"模块级 的 \"dunders\"（即有两个前导和两个尾部下划线的名称），"
"如 ``__all__``，``__author__``，``__version__``，等等。"
"应该放在模块文档串之后，但在任何导入语句之前，*除了*  ``from __future__`` 导入。"
"Python 规定，future 的导入必须出现在模块中的任何其他代码之前，除了文档字符串 ::"

#: ../../pep-0008.txt:425
msgid "String Quotes"
msgstr "字符串引号"

#: ../../pep-0008.txt:427
msgid ""
"In Python, single-quoted strings and double-quoted strings are the same."
"  This PEP does not make a recommendation for this.  Pick a rule and "
"stick to it.  When a string contains single or double quote characters, "
"however, use the other one to avoid backslashes in the string. It "
"improves readability."
msgstr ""
"在Python 中，单引号字符串和双引号字符串是一样的。"
"本 PEP 并没有对此提出建议。"
"选择一个规则并坚持下去。"
"然而，当一个字符串包含单引号或双引号字符时，使用另一个，以避免字符串中的反斜线。"
"它可以提高可读性。"

#: ../../pep-0008.txt:433
msgid ""
"For triple-quoted strings, always use double quote characters to be "
"consistent with the docstring convention in PEP 257."
msgstr ""
"对于三重引号的字符串，总是使用双引号字符，以便与 PEP 257 中的文档字符串约定一致。"

#: ../../pep-0008.txt:438
msgid "Whitespace in Expressions and Statements"
msgstr "表达式和语句中的空格"

#: ../../pep-0008.txt:441
msgid "Pet Peeves"
msgstr ""

#: ../../pep-0008.txt:443
msgid "Avoid extraneous whitespace in the following situations:"
msgstr "在以下情况下要避免不相干的空白："

#: ../../pep-0008.txt:445
msgid "Immediately inside parentheses, brackets or braces::"
msgstr "紧挨着小括号、大括号或圆括号的地方 ::"

#: ../../pep-0008.txt:455
msgid "Between a trailing comma and a following close parenthesis::"
msgstr "在尾部的逗号和后面的闭合小括号之间 ::"

#: ../../pep-0008.txt:465
msgid "Immediately before a comma, semicolon, or colon::"
msgstr "紧接在逗号、分号或冒号之前 ::"

#: ../../pep-0008.txt:475
msgid ""
"However, in a slice the colon acts like a binary operator, and should "
"have equal amounts on either side (treating it as the operator with the "
"lowest priority).  In an extended slice, both colons must have the same "
"amount of spacing applied.  Exception: when a slice parameter is omitted,"
" the space is omitted::"
msgstr ""
"然而，在一个切片中，冒号的作用就像一个二元运算符，两边的数量应该相等（把它当作优先级最低的运算符）。"
"在一个扩展的切片中，两个冒号都必须应用相同数量的间距。"
"例外：当一个切片参数被省略时，空格被省略 ::"

#: ../../pep-0008.txt:496
msgid ""
"Immediately before the open parenthesis that starts the argument list of "
"a function call::"
msgstr ""
"紧挨着开始函数调用的参数列表的开放括号之前 ::"

#: ../../pep-0008.txt:507
msgid ""
"Immediately before the open parenthesis that starts an indexing or "
"slicing::"
msgstr ""
"紧接着开始索引或切片的开放括号之前 ::"

#: ../../pep-0008.txt:518
msgid ""
"More than one space around an assignment (or other) operator to align it "
"with another::"
msgstr ""
"在一个赋值（或其他）运算符周围有一个以上的空格，以使其与另一个运算符对齐 ::"

#: ../../pep-0008.txt:534
msgid "Other Recommendations"
msgstr "其他建议"

#: ../../pep-0008.txt:536
msgid ""
"Avoid trailing whitespace anywhere.  Because it's usually invisible, it "
"can be confusing: e.g. a backslash followed by a space and a newline does"
" not count as a line continuation marker.  Some editors don't preserve it"
" and many projects (like CPython itself) have pre-commit hooks that "
"reject it."
msgstr ""
"在任何地方都要避免尾部的空白。"
"因为它通常是不可见的，它可能会引起混淆："
"例如，一个反斜杠后面有一个空格和一个换行符，并不算作一个续行标记。"
"一些编辑器不保留它，许多项目（如 CPython 本身）有预提交钩子，拒绝它。"

#: ../../pep-0008.txt:542
msgid ""
"Always surround these binary operators with a single space on either "
"side: assignment (``=``), augmented assignment (``+=``, ``-=`` etc.), "
"comparisons (``==``, ``<``, ``>``, ``!=``, ``<>``, ``<=``, ``>=``, "
"``in``, ``not in``, ``is``, ``is not``), Booleans (``and``, ``or``, "
"``not``)."
msgstr ""
"总是在这些二元运算符的两边用一个空格环绕："
"赋值（``=``），增强赋值（``+=``，``-=``等），"
"比较（``=`，``<``，``>``，``！=``，``<>``，``<=``，``>=``，``in``，``not in``，``is``，``is not``），"
"布尔运算（``and``，``or`，``not``）。"

#: ../../pep-0008.txt:548
msgid ""
"If operators with different priorities are used, consider adding "
"whitespace around the operators with the lowest priority(ies). Use your "
"own judgment; however, never use more than one space, and always have the"
" same amount of whitespace on both sides of a binary operator::"
msgstr ""
"如果使用了不同优先级的运算符，考虑在优先级最低的运算符周围添加空白。"
"使用你自己的判断；然而，永远不要使用一个以上的空格，并且在二元运算符的两边总是有相同数量的空格 ::"

#: ../../pep-0008.txt:570
msgid ""
"Function annotations should use the normal rules for colons and always "
"have spaces around the ``->`` arrow if present.  (See `Function "
"Annotations`_ below for more about function annotations.)::"
msgstr ""
"函数注释应该使用正常的冒号规则，如果存在 ``->`` 箭头，则始终在其周围有空格。"
"（关于函数注释的更多信息，请参见下面的 `函数注解`_ ） ::"

#: ../../pep-0008.txt:584
msgid ""
"Don't use spaces around the ``=`` sign when used to indicate a keyword "
"argument, or when used to indicate a default value for an *unannotated* "
"function parameter::"
msgstr ""
"当用于表示一个关键字参数时，或用于表示一个 *未注解的* 函数参数的默认值时，"
"不要在 ``=`` 符号周围使用空格 ::"

#: ../../pep-0008.txt:599
msgid ""
"When combining an argument annotation with a default value, however, do "
"use spaces around the ``=`` sign::"
msgstr ""
"但是，当把参数注解与默认值结合起来时，请在 ``=`` 符号周围使用空格 ::"

#: ../../pep-0008.txt:612
msgid ""
"Compound statements (multiple statements on the same line) are generally "
"discouraged::"
msgstr ""
"一般不鼓励使用复合语句（同一行的多个语句） ::"

#: ../../pep-0008.txt:622 ../../pep-0008.txt:632
msgid "Rather not::"
msgstr "宁可不做 ::"

#: ../../pep-0008.txt:628
msgid ""
"While sometimes it's okay to put an if/for/while with a small body on the"
" same line, never do this for multi-clause statements.  Also avoid "
"folding such long lines!"
msgstr ""
"虽然有时把 if/for/while 和小的主体放在同一行是可以的，但对于多条款的语句，千万不要这样做。"
"也要避免折叠这样的长行！"

#: ../../pep-0008.txt:639
msgid "Definitely not::"
msgstr "绝对不行 ::"

#: ../../pep-0008.txt:655
msgid "When to Use Trailing Commas"
msgstr "何时使用尾部逗号"

#: ../../pep-0008.txt:657
msgid ""
"Trailing commas are usually optional, except they are mandatory when "
"making a tuple of one element.  For clarity, it is recommended to "
"surround the latter in (technically redundant) parentheses::"
msgstr ""
"尾部逗号通常是可选的，但在制作一个元素的元组时是必须的。"
"为了清楚起见，建议用（技术上多余的）小括号包围后者 ::"

#: ../../pep-0008.txt:669
msgid ""
"When trailing commas are redundant, they are often helpful when a version"
" control system is used, when a list of values, arguments or imported "
"items is expected to be extended over time.  The pattern is to put each "
"value (etc.) on a line by itself, always adding a trailing comma, and add"
" the close parenthesis/bracket/brace on the next line. However it does "
"not make sense to have a trailing comma on the same line as the closing "
"delimiter (except in the above case of singleton tuples)::"
msgstr ""
"当尾部逗号是多余的，当使用版本控制系统时，"
"当一个值、参数或导入项的列表预计会随着时间的推移而扩展时，尾部逗号往往是有帮助的。"
"其模式是将每个值（等）单独放在一行，总是添加一个尾部逗号，并在下一行添加封闭的小括号/括弧/括号。"
"然而，将尾部逗号与闭合分隔符放在同一行中是没有意义的（除了上述单子图元的情况） ::"

#: ../../pep-0008.txt:695
msgid "Comments"
msgstr "注释"

#: ../../pep-0008.txt:697
msgid ""
"Comments that contradict the code are worse than no comments.  Always "
"make a priority of keeping the comments up-to-date when the code changes!"
msgstr ""
"与代码相抵触的注释比没有注释更糟糕。当代码发生变化时，一定要优先保持注释的更新！"

#: ../../pep-0008.txt:701
msgid ""
"Comments should be complete sentences.  The first word should be "
"capitalized, unless it is an identifier that begins with a lower case "
"letter (never alter the case of identifiers!)."
msgstr ""
"注释应该是完整的句子。"
"第一个词应该大写，除非它是一个以小写字母开头的标识符（永远不要改变标识符的大小写！）。"

#: ../../pep-0008.txt:705
msgid ""
"Block comments generally consist of one or more paragraphs built out of "
"complete sentences, with each sentence ending in a period."
msgstr ""
"块注释一般由一个或多个完整的句子组成的段落组成，每个句子以句号结束。"

#: ../../pep-0008.txt:708
msgid ""
"You should use two spaces after a sentence-ending period in multi- "
"sentence comments, except after the final sentence."
msgstr ""
"在多句注释中，你应该在句子结束的句号后使用两个空格，但最后一句话后除外。"

#: ../../pep-0008.txt:711
msgid ""
"Ensure that your comments are clear and easily understandable to other "
"speakers of the language you are writing in."
msgstr ""
"确保你的注释清晰明了，容易被其他使用你所写语言的人理解。"

#: ../../pep-0008.txt:714
#, python-format
msgid ""
"Python coders from non-English speaking countries: please write your "
"comments in English, unless you are 120% sure that the code will never be"
" read by people who don't speak your language."
msgstr ""
"来自非英语国家的 Python 编码员："
"请用英语写注释，除非你有 120% 的把握，代码永远不会被不讲你的语言的人阅读。"

#: ../../pep-0008.txt:719
msgid "Block Comments"
msgstr "块注释"

#: ../../pep-0008.txt:721
msgid ""
"Block comments generally apply to some (or all) code that follows them, "
"and are indented to the same level as that code.  Each line of a block "
"comment starts with a ``#`` and a single space (unless it is indented "
"text inside the comment)."
msgstr ""
"块注释通常适用于它们后面的一些（或所有）代码，并与该代码缩进到同一水平。"
"块注释的每一行都以 ``#`` 和一个空格开始（除非它是注释内的缩进文本）。"

#: ../../pep-0008.txt:726
msgid ""
"Paragraphs inside a block comment are separated by a line containing a "
"single ``#``."
msgstr ""
"块注释内的段落由包含单个 ``#`` 的行来分隔。"

#: ../../pep-0008.txt:730
msgid "Inline Comments"
msgstr "内联注释"

#: ../../pep-0008.txt:732
msgid "Use inline comments sparingly."
msgstr "尽量少使用内联注释。"

#: ../../pep-0008.txt:734
msgid ""
"An inline comment is a comment on the same line as a statement. Inline "
"comments should be separated by at least two spaces from the statement.  "
"They should start with a # and a single space."
msgstr ""
"内联注释是指与语句在同一行的注释。内联注释应与语句至少隔开两个空格。 "
"它们应该以 # 和一个空格开始。"

#: ../../pep-0008.txt:738
msgid ""
"Inline comments are unnecessary and in fact distracting if they state the"
" obvious.  Don't do this::"
msgstr ""
"内联注释是不必要的，事实上，如果它们说明了明显的问题，就会分散注意力。"
"不要这样做 ::"

#: ../../pep-0008.txt:743
msgid "But sometimes, this is useful::"
msgstr "但有时，这是很有用的 ::"

#: ../../pep-0008.txt:748
msgid "Documentation Strings"
msgstr "文档字符串"

#: ../../pep-0008.txt:750
msgid ""
"Conventions for writing good documentation strings (a.k.a. "
"\"docstrings\") are immortalized in PEP 257."
msgstr ""
"编写好的文档字符串（又称 \"docstrings\"）的惯例在 PEP 257 中得到了永生。"

#: ../../pep-0008.txt:753
msgid ""
"Write docstrings for all public modules, functions, classes, and methods."
"  Docstrings are not necessary for non-public methods, but you should "
"have a comment that describes what the method does.  This comment should "
"appear after the ``def`` line."
msgstr ""
"为所有公共模块、函数、类和方法编写文档字符串。"
"对于非公开的方法，不需要文档字符串，但你应该有一个注释来描述该方法的作用。"
"这个注释应该出现在 ``def`` 行之后。"

#: ../../pep-0008.txt:758
msgid ""
"PEP 257 describes good docstring conventions.  Note that most "
"importantly, the ``\"\"\"`` that ends a multiline docstring should be on "
"a line by itself::"
msgstr ""
"PEP 257 描述了良好的文档字符串约定。"
"请注意，最重要的是，结束多行文档字符串的 ``\"\"\"`` 应该自己在一行中 ::"

#: ../../pep-0008.txt:767
msgid ""
"For one liner docstrings, please keep the closing ``\"\"\"`` on the same "
"line::"
msgstr ""
"对于单行的文件串，请将结尾的 ``\"\"\"`` 放在同一行 ::"

#: ../../pep-0008.txt:774
msgid "Naming Conventions"
msgstr "命名公约"

#: ../../pep-0008.txt:776
msgid ""
"The naming conventions of Python's library are a bit of a mess, so we'll "
"never get this completely consistent -- nevertheless, here are the "
"currently recommended naming standards.  New modules and packages "
"(including third party frameworks) should be written to these standards, "
"but where an existing library has a different style, internal consistency"
" is preferred."
msgstr ""
"Python 库的命名规则有点乱，所以我们永远不会让它完全一致 -- 尽管如此，这里是目前推荐的命名标准。"
"新的模块和包（包括第三方框架）应该按照这些标准来编写，但如果现有的库有不同的风格，内部一致性是首选。"

#: ../../pep-0008.txt:784
msgid "Overriding Principle"
msgstr "覆盖原则"

#: ../../pep-0008.txt:786
msgid ""
"Names that are visible to the user as public parts of the API should "
"follow conventions that reflect usage rather than implementation."
msgstr ""
"作为 API 的公共部分，对用户可见的名称应该遵循 reflect 用法而不是实现的惯例。"

#: ../../pep-0008.txt:790
msgid "Descriptive: Naming Styles"
msgstr "描述性的：命名方式"

#: ../../pep-0008.txt:792
msgid ""
"There are a lot of different naming styles.  It helps to be able to "
"recognize what naming style is being used, independently from what they "
"are used for."
msgstr ""
"有很多不同的命名方式。能够认识到使用的是什么命名方式，与它们的用途无关，这很有帮助。"

#: ../../pep-0008.txt:796
msgid "The following naming styles are commonly distinguished:"
msgstr "常用的命名方式有以下几种："

#: ../../pep-0008.txt:798
msgid "``b`` (single lowercase letter)"
msgstr "``b`` （单个小写字母）"

#: ../../pep-0008.txt:799
msgid "``B`` (single uppercase letter)"
msgstr "``B`` （单个大写字母）"

#: ../../pep-0008.txt:800
msgid "``lowercase``"
msgstr ""

#: ../../pep-0008.txt:801
msgid "``lower_case_with_underscores``"
msgstr ""

#: ../../pep-0008.txt:802
msgid "``UPPERCASE``"
msgstr ""

#: ../../pep-0008.txt:803
msgid "``UPPER_CASE_WITH_UNDERSCORES``"
msgstr ""

#: ../../pep-0008.txt:804
msgid ""
"``CapitalizedWords`` (or CapWords, or CamelCase -- so named because of "
"the bumpy look of its letters [4]_).  This is also sometimes known as "
"StudlyCaps."
msgstr ""
"``CapitalizedWords`` (或 CapWords，或 CamelCase -- 因其字母 [4]_ 的凹凸外观而得名）。"
"这有时也被称为 StudlyCaps。"

#: ../../pep-0008.txt:808
msgid ""
"Note: When using acronyms in CapWords, capitalize all the letters of the "
"acronym.  Thus HTTPServerError is better than HttpServerError."
msgstr ""
"注意：在 CapWords 中使用缩略语时，要将缩略语的所有字母大写。"
"因此，HTTPServerError 比 HttpServerError 好。"

#: ../../pep-0008.txt:811
msgid ""
"``mixedCase`` (differs from CapitalizedWords by initial lowercase "
"character!)"
msgstr ""
"``mixedCase`` （与 CapitalizedWords 不同的是首字母小写的字符！）"

#: ../../pep-0008.txt:813
msgid "``Capitalized_Words_With_Underscores`` (ugly!)"
msgstr "``Capitalized_Words_With_Underscores`` （丑陋!）"

#: ../../pep-0008.txt:815
msgid ""
"There's also the style of using a short unique prefix to group related "
"names together.  This is not used much in Python, but it is mentioned for"
" completeness.  For example, the ``os.stat()`` function returns a tuple "
"whose items traditionally have names like ``st_mode``, ``st_size``, "
"``st_mtime`` and so on.  (This is done to emphasize the correspondence "
"with the fields of the POSIX system call struct, which helps programmers "
"familiar with that.)"
msgstr ""
"还有一种风格是使用简短的唯一前缀将相关的名字组合在一起。"
"这在 Python 中用得不多，但为了完整起见，还是要提到。"
"例如，``os.stat()`` 函数返回一个元组，其项目传统上有 ``st_mode``、``st_size``、``st_mtime`` 等名称。"
"（这样做是为了强调与 POSIX 系统调用结构的字段的对应关系，这有助于熟悉该结构的程序员。）"

#: ../../pep-0008.txt:823
msgid ""
"The X11 library uses a leading X for all its public functions.  In "
"Python, this style is generally deemed unnecessary because attribute and "
"method names are prefixed with an object, and function names are prefixed"
" with a module name."
msgstr ""
"X11 库在其所有的公共函数中使用前导 X。"
"在 Python 中，这种风格通常被认为是不必要的，"
"因为属性和方法名的前缀是一个对象，而函数名的前缀是一个模块名。"

#: ../../pep-0008.txt:828
msgid ""
"In addition, the following special forms using leading or trailing "
"underscores are recognized (these can generally be combined with any case"
" convention):"
msgstr ""
"此外，还承认以下使用前导或尾部下划线的特殊形式（这些通常可以与任何大小写惯例相结合）："

#: ../../pep-0008.txt:832
msgid ""
"``_single_leading_underscore``: weak \"internal use\" indicator. E.g. "
"``from M import *`` does not import objects whose names start with an "
"underscore."
msgstr ""
"``_single_leading_underscore``：weak “内部使用” 指标。"
"例如，``from M import *`` 不会导入名称以下划线开头的对象。"

#: ../../pep-0008.txt:836
msgid ""
"``single_trailing_underscore_``: used by convention to avoid conflicts "
"with Python keyword, e.g. ::"
msgstr ""
"``single_trailing_underscore_``：按惯例使用，以避免与 Python 关键字冲突，例如 ::"

#: ../../pep-0008.txt:841
msgid ""
"``__double_leading_underscore``: when naming a class attribute, invokes "
"name mangling (inside class FooBar, ``__boo`` becomes ``_FooBar__boo``; "
"see below)."
msgstr ""
"``__double_leading_underscore``：当命名一个类的属性时，会调用名称混用"
"（在类 FooBar 中，``__boo`` 变成 ``_FooBar__boo``；见下文）。"

#: ../../pep-0008.txt:845
msgid ""
"``__double_leading_and_trailing_underscore__``: \"magic\" objects or "
"attributes that live in user-controlled namespaces. E.g. ``__init__``, "
"``__import__`` or ``__file__``.  Never invent such names; only use them "
"as documented."
msgstr ""
"``__double_leading_and_trailing_underscore__``：实时在用户控制的命名空间中的 \"magic\" 对象或属性。"
"例如：``__init__``，``__import__`` 或 ``__file__``。"
"不要发明这样的名字；只使用文件规定的名字。"

#: ../../pep-0008.txt:851
msgid "Prescriptive: Naming Conventions"
msgstr "规范性的：命名规则"

#: ../../pep-0008.txt:854
msgid "Names to Avoid"
msgstr "应避免的名称"

#: ../../pep-0008.txt:856
msgid ""
"Never use the characters 'l' (lowercase letter el), 'O' (uppercase letter"
" oh), or 'I' (uppercase letter eye) as single character variable names."
msgstr ""
"永远不要使用字符 'l'（小写字母 el）、'O'（大写字母 oh）或 'I'（大写字母 eye）作为单字符变量名。"

#: ../../pep-0008.txt:860
msgid ""
"In some fonts, these characters are indistinguishable from the numerals "
"one and zero.  When tempted to use 'l', use 'L' instead."
msgstr ""
"在某些字体中，这些字符与数字 1 和 0 无法区分。当想使用 'l' 时，请使用 'L' 代替。"

#: ../../pep-0008.txt:864
msgid "ASCII Compatibility"
msgstr "ASCII 兼容性"

#: ../../pep-0008.txt:866
msgid ""
"Identifiers used in the standard library must be ASCII compatible as "
"described in the `policy section "
"<https://www.python.org/dev/peps/pep-3131/#policy-specification>`_ of PEP"
" 3131."
msgstr ""
"标准库中使用的标识符必须是 ASCII 兼容的，如 PEP 3131 的 "
"`政策部分 <https://www.python.org/dev/peps/pep-3131/#policy-specification>`_ 所述。"

#: ../../pep-0008.txt:872
msgid "Package and Module Names"
msgstr "包和模块名称"

#: ../../pep-0008.txt:874
msgid ""
"Modules should have short, all-lowercase names.  Underscores can be used "
"in the module name if it improves readability.  Python packages should "
"also have short, all-lowercase names, although the use of underscores is "
"discouraged."
msgstr ""
"模块应该有短的、全小写的名字。"
"如果能提高可读性，可以在模块名称中使用下划线。"
"Python 包也应该有短的、全小写的名字，尽管不鼓励使用下划线。"

#: ../../pep-0008.txt:879
msgid ""
"When an extension module written in C or C++ has an accompanying Python "
"module that provides a higher level (e.g. more object oriented) "
"interface, the C/C++ module has a leading underscore (e.g. ``_socket``)."
msgstr ""
"当一个用 C 或 C++ 编写的扩展模块有一个附带的 Python 模块，"
"提供了一个更高级别的（例如，更面向对象的）接口时，C/C++ 模块有一个前导下划线（例如 ``_socket``）。"

#: ../../pep-0008.txt:885
msgid "Class Names"
msgstr "类名称"

#: ../../pep-0008.txt:887
msgid "Class names should normally use the CapWords convention."
msgstr "类名通常应使用 CapWords 惯例。"

#: ../../pep-0008.txt:889
msgid ""
"The naming convention for functions may be used instead in cases where "
"the interface is documented and used primarily as a callable."
msgstr ""
"在接口被记录下来并主要作为可调用的情况下，可以用函数的命名惯例来代替。"

#: ../../pep-0008.txt:892
msgid ""
"Note that there is a separate convention for builtin names: most builtin "
"names are single words (or two words run together), with the CapWords "
"convention used only for exception names and builtin constants."
msgstr ""
"请注意，对于内建程序的名称有一个单独的约定："
"大多数内建程序的名称是单字（或两个字并列），CapWords 约定只用于异常名称和内建程序常量。"

#: ../../pep-0008.txt:897
msgid "Type Variable Names"
msgstr "类型变量名称"

#: ../../pep-0008.txt:899
msgid ""
"Names of type variables introduced in PEP 484 should normally use "
"CapWords preferring short names: ``T``, ``AnyStr``, ``Num``. It is "
"recommended to add suffixes ``_co`` or ``_contra`` to the variables used "
"to declare covariant or contravariant behavior correspondingly::"
msgstr ""
"PEP 484 中引入的类型变量的名称通常应该使用 CapWords，倾向于使用短名称：``T``、``AnyStr``、``Num``。"
"建议在用于声明协变或反变行为的变量上添加后缀 ``_co`` 或 ``_contra``，相应地 ::"

#: ../../pep-0008.txt:910
msgid "Exception Names"
msgstr "异常名称"

#: ../../pep-0008.txt:912
msgid ""
"Because exceptions should be classes, the class naming convention applies"
" here.  However, you should use the suffix \"Error\" on your exception "
"names (if the exception actually is an error)."
msgstr ""
"因为异常应该是类，所以类的命名惯例在此适用。"
"然而，你应该在你的异常名称上使用后缀 \"Error\"（如果异常实际上是一个错误）。"

#: ../../pep-0008.txt:917
msgid "Global Variable Names"
msgstr "全局变量名称"

#: ../../pep-0008.txt:919
msgid ""
"(Let's hope that these variables are meant for use inside one module "
"only.)  The conventions are about the same as those for functions."
msgstr ""
"（让我们希望这些变量只在一个模块内使用。）惯例与函数的惯例大致相同。"

#: ../../pep-0008.txt:922
msgid ""
"Modules that are designed for use via ``from M import *`` should use the "
"``__all__`` mechanism to prevent exporting globals, or use the older "
"convention of prefixing such globals with an underscore (which you might "
"want to do to indicate these globals are \"module non-public\")."
msgstr ""
"为通过 ``from M import *`` 使用而设计的模块应该使用 ``__all__`` 机制来防止导出 globals，"
"或者使用较早的惯例，在这种 globals 前加一个下划线（你可能想这样做，以表明这些 globals 是 ``模块非公共``）。"

#: ../../pep-0008.txt:929
msgid "Function and Variable Names"
msgstr "函数和变量名称"

#: ../../pep-0008.txt:931
msgid ""
"Function names should be lowercase, with words separated by underscores "
"as necessary to improve readability."
msgstr ""
"函数名称应采用小写，必要时用下划线隔开，以提高可读性。"

#: ../../pep-0008.txt:934
msgid "Variable names follow the same convention as function names."
msgstr "变量名称遵循与函数名称相同的惯例。"

#: ../../pep-0008.txt:936
msgid ""
"mixedCase is allowed only in contexts where that's already the prevailing"
" style (e.g. threading.py), to retain backwards compatibility."
msgstr ""
"只允许在已经是主流风格的情况下使用 mixedCase（例如 threading.py），以保持向后兼容。"

#: ../../pep-0008.txt:941
msgid "Function and Method Arguments"
msgstr "函数和方法的参数"

#: ../../pep-0008.txt:943
msgid "Always use ``self`` for the first argument to instance methods."
msgstr "总是使用 ``self`` 作为实例方法的第一个参数。"

#: ../../pep-0008.txt:945
msgid "Always use ``cls`` for the first argument to class methods."
msgstr "总是使用 ``cls`` 作为类方法的第一个参数。"

#: ../../pep-0008.txt:947
msgid ""
"If a function argument's name clashes with a reserved keyword, it is "
"generally better to append a single trailing underscore rather than use "
"an abbreviation or spelling corruption.  Thus ``class_`` is better than "
"``clss``.  (Perhaps better is to avoid such clashes by using a synonym.)"
msgstr ""
"如果一个函数参数的名字与一个保留的关键字冲突，一般来说，最好在后面附加一个下划线，"
"而不是使用缩写或拼写错误。因此 ``class_`` 比 ``clss`` 好。"
"（也许更好的是通过使用同义词来避免这种冲突。）"

#: ../../pep-0008.txt:954
msgid "Method Names and Instance Variables"
msgstr "方法名称和实例变量"

#: ../../pep-0008.txt:956
msgid ""
"Use the function naming rules: lowercase with words separated by "
"underscores as necessary to improve readability."
msgstr ""
"使用函数命名规则：小写字母，必要时用下划线隔开单词，以提高可读性。"

#: ../../pep-0008.txt:959
msgid ""
"Use one leading underscore only for non-public methods and instance "
"variables."
msgstr ""
"只对非公开方法和实例变量使用一个前导下划线。"

#: ../../pep-0008.txt:962
msgid ""
"To avoid name clashes with subclasses, use two leading underscores to "
"invoke Python's name mangling rules."
msgstr ""
"为了避免与子类的名称冲突，使用两个前导下划线来调用 Python 的名称处理规则。"

#: ../../pep-0008.txt:965
msgid ""
"Python mangles these names with the class name: if class Foo has an "
"attribute named ``__a``, it cannot be accessed by ``Foo.__a``.  (An "
"insistent user could still gain access by calling ``Foo._Foo__a``.) "
"Generally, double leading underscores should be used only to avoid name "
"conflicts with attributes in classes designed to be subclassed."
msgstr ""
"Python 将这些名字与类的名字混为一谈：如果类 Foo 有一个名为 ``__a`` 的属性，"
"它就不能被 ``Foo.__a`` 访问。"
"（一个执着的用户仍然可以通过调用 ``Foo._Foo__a`` 获得访问权。）"
"一般来说，双引号应该只用来避免与设计为子类的类中的属性发生名称冲突。"

#: ../../pep-0008.txt:971
msgid "Note: there is some controversy about the use of __names (see below)."
msgstr "注意：关于 ``__names`` 的使用有一些争议（见下文）。"

#: ../../pep-0008.txt:974
msgid "Constants"
msgstr "常量"

#: ../../pep-0008.txt:976
msgid ""
"Constants are usually defined on a module level and written in all "
"capital letters with underscores separating words.  Examples include "
"``MAX_OVERFLOW`` and ``TOTAL``."
msgstr ""
"常量通常定义在模块层面，用大写字母书写，用下划线分隔单词。例如 ``MAX_OVERFLOW`` 和 ``TOTAL``。"

#: ../../pep-0008.txt:981
msgid "Designing for Inheritance"
msgstr "继承设计"

#: ../../pep-0008.txt:983
msgid ""
"Always decide whether a class's methods and instance variables "
"(collectively: \"attributes\") should be public or non-public.  If in "
"doubt, choose non-public; it's easier to make it public later than to "
"make a public attribute non-public."
msgstr ""
"一定要决定一个类的方法和实例变量（统称：\"属性\"（attributes））应该是公共的还是非公共的。"
"如果有疑问，请选择非公共的；以后把它变成公共的比把公共属性变成非公共的更容易。"

#: ../../pep-0008.txt:988
msgid ""
"Public attributes are those that you expect unrelated clients of your "
"class to use, with your commitment to avoid backwards incompatible "
"changes.  Non-public attributes are those that are not intended to be "
"used by third parties; you make no guarantees that non-public attributes "
"won't change or even be removed."
msgstr ""
"公共属性是那些你期望你的类的无关客户使用的属性，你的承诺是避免向后不兼容的变化。"
"非公共属性是那些不打算被第三方使用的属性；你不保证非公共属性不会改变，甚至被删除。"

#: ../../pep-0008.txt:994
msgid ""
"We don't use the term \"private\" here, since no attribute is really "
"private in Python (without a generally unnecessary amount of work)."
msgstr ""
"我们在这里不使用术语 \"private\"，"
"因为在 Python 中没有任何属性是真正私有的（没有一般不必要的工作）。"

#: ../../pep-0008.txt:997
msgid ""
"Another category of attributes are those that are part of the \"subclass "
"API\" (often called \"protected\" in other languages).  Some classes are "
"designed to be inherited from, either to extend or modify aspects of the "
"class's behavior.  When designing such a class, take care to make "
"explicit decisions about which attributes are public, which are part of "
"the subclass API, and which are truly only to be used by your base class."
msgstr ""
"另一类属性是那些属于 “子类 API” 的属性（在其他语言中通常称为 \"protected\"）。"
"有些类被设计成可以被继承，以扩展或修改该类行为的各个方面。"
"在设计这样的类时，要注意明确决定哪些属性是公共的，哪些是子类 API 的一部分，哪些是真正只能由基类使用的。"

#: ../../pep-0008.txt:1005
msgid "With this in mind, here are the Pythonic guidelines:"
msgstr "考虑到这一点，下面是 Pythonic 的准则："

#: ../../pep-0008.txt:1007
msgid "Public attributes should have no leading underscores."
msgstr "公共属性不应该有前导下划线。"

#: ../../pep-0008.txt:1009
msgid ""
"If your public attribute name collides with a reserved keyword, append a "
"single trailing underscore to your attribute name.  This is preferable to"
" an abbreviation or corrupted spelling.  (However, notwithstanding this "
"rule, 'cls' is the preferred spelling for any variable or argument which "
"is known to be a class, especially the first argument to a class method.)"
msgstr ""
"如果你的公共属性名称与一个保留的关键字相冲突，请在你的属性名称后面加上一个下划线。"
"这比缩写或破坏性的拼写更可取。"
"（然而，尽管有这个规则，'cls' 是任何已知为类的变量或参数的首选拼写，特别是类方法的第一个参数。）"

#: ../../pep-0008.txt:1016
msgid "Note 1: See the argument name recommendation above for class methods."
msgstr "注 1：见上面关于类方法的参数名称建议。"

#: ../../pep-0008.txt:1018
msgid ""
"For simple public data attributes, it is best to expose just the "
"attribute name, without complicated accessor/mutator methods.  Keep in "
"mind that Python provides an easy path to future enhancement, should you "
"find that a simple data attribute needs to grow functional behavior.  In "
"that case, use properties to hide functional implementation behind simple"
" data attribute access syntax."
msgstr ""
"对于简单的公共数据属性，最好是只公开属性名称，而不使用复杂的访问器/混合器方法。"
"请记住，如果你发现一个简单的数据属性需要增加功能行为，Python 提供了一个简单的路径来实现未来的增强。"
"在这种情况下，使用属性将功能实现隐藏在简单的数据属性访问语法后面。"

#: ../../pep-0008.txt:1026
msgid ""
"Note 1: Try to keep the functional behavior side-effect free, although "
"side-effects such as caching are generally fine."
msgstr ""
"注意1：尽量保持功能行为不受副作用影响，尽管缓存等副作用一般来说是可以的。"

#: ../../pep-0008.txt:1029
msgid ""
"Note 2: Avoid using properties for computationally expensive operations; "
"the attribute notation makes the caller believe that access is "
"(relatively) cheap."
msgstr ""
"注意2：避免使用属性来进行计算上昂贵的操作；"
"属性符号使调用者相信访问是（相对）便宜的。"

#: ../../pep-0008.txt:1033
msgid ""
"If your class is intended to be subclassed, and you have attributes that "
"you do not want subclasses to use, consider naming them with double "
"leading underscores and no trailing underscores.  This invokes Python's "
"name mangling algorithm, where the name of the class is mangled into the "
"attribute name.  This helps avoid attribute name collisions should "
"subclasses inadvertently contain attributes with the same name."
msgstr ""
"如果你的类打算被子类化，并且你有不想让子类使用的属性，考虑用双前导下划线和无尾部下划线来命名它们。"
"这将调用 Python 的名称混合算法，类的名称将被混合成属性名称。"
"这有助于在子类无意中包含相同名称的属性时，避免属性名称的冲突"。

#: ../../pep-0008.txt:1041
msgid ""
"Note 1: Note that only the simple class name is used in the mangled name,"
" so if a subclass chooses both the same class name and attribute name, "
"you can still get name collisions."
msgstr ""
"注意1：注意只有简单的类名被用于混杂的名称中，所以如果一个子类同时选择相同的类名和属性名，你仍然可以得到名称碰撞。"

#: ../../pep-0008.txt:1045
msgid ""
"Note 2: Name mangling can make certain uses, such as debugging and "
"``__getattr__()``, less convenient.  However the name mangling algorithm "
"is well documented and easy to perform manually."
msgstr ""
"注意2：名字的拼写会使某些使用，如调试和 ``__getattr__()``，变得不那么方便。"
"然而，名称混合算法有很好的文件记录，并且很容易手动执行。"

#: ../../pep-0008.txt:1049
msgid ""
"Note 3: Not everyone likes name mangling.  Try to balance the need to "
"avoid accidental name clashes with potential use by advanced callers."
msgstr ""
"注3：不是每个人都喜欢名字的拼写。尽量在避免意外的姓名冲突与高级调用者的潜在使用之间取得平衡。"

#: ../../pep-0008.txt:1054
msgid "Public and Internal Interfaces"
msgstr "公共和内部接口"

#: ../../pep-0008.txt:1056
msgid ""
"Any backwards compatibility guarantees apply only to public interfaces. "
"Accordingly, it is important that users be able to clearly distinguish "
"between public and internal interfaces."
msgstr ""
"任何向后兼容的保证只适用于公共接口。"
"因此，重要的是，用户要能够明确区分公共接口和内部接口。"

#: ../../pep-0008.txt:1060
msgid ""
"Documented interfaces are considered public, unless the documentation "
"explicitly declares them to be provisional or internal interfaces exempt "
"from the usual backwards compatibility guarantees. All undocumented "
"interfaces should be assumed to be internal."
msgstr ""
"文档化的接口被认为是公开的，除非文档明确声明它们是临时的或内部的接口，免于通常的向后兼容性保证。"
"所有没有记录的接口应该被认为是内部的。"

#: ../../pep-0008.txt:1065
msgid ""
"To better support introspection, modules should explicitly declare the "
"names in their public API using the ``__all__`` attribute. Setting "
"``__all__`` to an empty list indicates that the module has no public API."
msgstr ""
"为了更好地支持自省，模块应该在它们的公共 API 中使用 ``__all__`` 属性明确地声明名称。"
"将 ``__all__`` 设置为一个空列表，表示该模块没有公共 API。"

#: ../../pep-0008.txt:1069
msgid ""
"Even with ``__all__`` set appropriately, internal interfaces (packages, "
"modules, classes, functions, attributes or other names) should still be "
"prefixed with a single leading underscore."
msgstr ""
"即使适当地设置了 ``__all__``，内部接口（包、模块、类、函数、属性或其他名称）仍应在前缀中加入一个单引号。"

#: ../../pep-0008.txt:1073
msgid ""
"An interface is also considered internal if any containing namespace "
"(package, module or class) is considered internal."
msgstr ""
"如果任何包含命名空间（包、模块或类）的接口也被认为是内部的。"

#: ../../pep-0008.txt:1076
msgid ""
"Imported names should always be considered an implementation detail. "
"Other modules must not rely on indirect access to such imported names "
"unless they are an explicitly documented part of the containing module's "
"API, such as ``os.path`` or a package's ``__init__`` module that exposes "
"functionality from submodules."
msgstr ""
"导入的名称应始终被视为一个实现细节。"
"其他模块不能依赖对这些导入名称的间接访问，除非它们是包含模块的 API 中明确记录的一部分，"
"例如 ``os.path`` 或包的 ``__init__`` 模块，它暴露了子模块的功能。"

#: ../../pep-0008.txt:1084
msgid "Programming Recommendations"
msgstr "编程推荐"

#: ../../pep-0008.txt:1086
msgid ""
"Code should be written in a way that does not disadvantage other "
"implementations of Python (PyPy, Jython, IronPython, Cython, Psyco, and "
"such)."
msgstr ""
"代码的编写方式不应不利于 Python 的其他实现（PyPy、Jython、IronPython、Cython、Psyco，等等）。"

#: ../../pep-0008.txt:1090
msgid ""
"For example, do not rely on CPython's efficient implementation of in-"
"place string concatenation for statements in the form ``a += b`` or ``a ="
" a + b``.  This optimization is fragile even in CPython (it only works "
"for some types) and isn't present at all in implementations that don't "
"use refcounting.  In performance sensitive parts of the library, the "
"``''.join()`` form should be used instead.  This will ensure that "
"concatenation occurs in linear time across various implementations."
msgstr ""
"例如，不要依赖 CPython 对 ``a += b`` 或 ``a = a + b`` 形式的语句进行原地字符串连接的有效实现。"
"这种优化即使在 CPython 中也是脆弱的（它只对某些类型有效），而且在不使用 refcounting 的实现中根本不存在。"
"在库的性能敏感部分，应该使用 ``''.join()`` 形式来代替。"
"这将确保连接在不同的实现中以线性时间发生。"

#: ../../pep-0008.txt:1099
msgid ""
"Comparisons to singletons like None should always be done with ``is`` or "
"``is not``, never the equality operators."
msgstr ""
"对 None 这样的单子（singletons）的比较应该总是用 ``is``  或 ``is not`` 来进行，而不是用等号运算符。"

#: ../../pep-0008.txt:1102
msgid ""
"Also, beware of writing ``if x`` when you really mean ``if x is not "
"None`` -- e.g. when testing whether a variable or argument that defaults "
"to None was set to some other value.  The other value might have a type "
"(such as a container) that could be false in a boolean context!"
msgstr ""
"另外，当你真正的意思是 \"如果 x 不是 None\" 时，要小心写 \"if x\" -- "
"例如，当测试一个默认为 None 的变量或参数是否被设置为其他值时。"
"其他的值可能有一个类型（如容器），在布尔环境中可能是 false！"

#: ../../pep-0008.txt:1108
msgid ""
"Use ``is not`` operator rather than ``not ... is``.  While both "
"expressions are functionally identical, the former is more readable and "
"preferred::"
msgstr ""
"使用 ``is not`` 运算符，而不是 ``not ... is``。"
"虽然这两个表达式在功能上是相同的，但前者更具可读性，是首选 ::"

#: ../../pep-0008.txt:1120
msgid ""
"When implementing ordering operations with rich comparisons, it is best "
"to implement all six operations (``__eq__``, ``__ne__``, ``__lt__``, "
"``__le__``, ``__gt__``, ``__ge__``) rather than relying on other code to "
"only exercise a particular comparison."
msgstr ""
"当用丰富的比较实现排序操作时，最好是实现所有的六种操作"
"（``__eq__``、``__ne__``、``__lt__``、``__le__``、``__gt__``、``__ge__``），"
"而不是依靠其他代码只行使一个特定的比较。"

#: ../../pep-0008.txt:1125
msgid ""
"To minimize the effort involved, the ``functools.total_ordering()`` "
"decorator provides a tool to generate missing comparison methods."
msgstr ""
"为了最大限度地减少所涉及的工作，``functools.total_ordering()`` 装饰器提供了一个工具来生成缺少的比较方法。"

#: ../../pep-0008.txt:1128
msgid ""
"PEP 207 indicates that reflexivity rules *are* assumed by Python. Thus, "
"the interpreter may swap ``y > x`` with ``x < y``, ``y >= x`` with ``x <="
" y``, and may swap the arguments of ``x == y`` and ``x != y``.  The "
"``sort()`` and ``min()`` operations are guaranteed to use the ``<`` "
"operator and the ``max()`` function uses the ``>`` operator.  However, it"
" is best to implement all six operations so that confusion doesn't arise "
"in other contexts."
msgstr ""
"PEP 207 表明，反身性规则被 Python 假定。"
"因此，解释器可以将 ``y > x`` 与 ``x < y`` 交换，``y >= x`` 与 ``x <= y`` 交换，"
"并且可以交换 ``x = y`` 和 ``x != y`` 的参数。"
"``sort()`` 和 ``max()`` 操作保证使用 ``<`` 操作符，``max()`` 函数使用 ``>`` 操作符。"
"然而，最好是实现所有六种操作，这样在其他情况下就不会出现混乱。"

#: ../../pep-0008.txt:1136
msgid ""
"Always use a def statement instead of an assignment statement that binds "
"a lambda expression directly to an identifier::"
msgstr ""
"总是使用 def 语句，而不是直接将 lambda 表达式与标识符绑定的赋值语句 ::"

#: ../../pep-0008.txt:1147
msgid ""
"The first form means that the name of the resulting function object is "
"specifically 'f' instead of the generic '<lambda>'. This is more useful "
"for tracebacks and string representations in general. The use of the "
"assignment statement eliminates the sole benefit a lambda expression can "
"offer over an explicit def statement (i.e. that it can be embedded inside"
" a larger expression)"
msgstr ""
"第一种形式意味着产生的函数对象的名称是具体的 'f'，而不是通用的 '<lambda>'。"
"这对回溯和一般的字符串表示法更有用。"
"使用赋值语句消除了 lambda 表达式比显式 def 语句所能提供的唯一好处（即它可以被嵌入到一个更大的表达式中）"

#: ../../pep-0008.txt:1154
msgid ""
"Derive exceptions from ``Exception`` rather than ``BaseException``. "
"Direct inheritance from ``BaseException`` is reserved for exceptions "
"where catching them is almost always the wrong thing to do."
msgstr ""
"从 ``Exception`` 派生异常，而不是 ``BaseException``。"
"直接继承自 ``BaseException`` 是为那些捕获异常几乎都是错误的事情而保留的。"

#: ../../pep-0008.txt:1158
msgid ""
"Design exception hierarchies based on the distinctions that code "
"*catching* the exceptions is likely to need, rather than the locations "
"where the exceptions are raised. Aim to answer the question \"What went "
"wrong?\" programmatically, rather than only stating that \"A problem "
"occurred\" (see PEP 3151 for an example of this lesson being learned for "
"the builtin exception hierarchy)"
msgstr ""
"设计异常等级时，要基于抓取异常的代码可能需要的区别，而不是异常发生的位置。"
"争取以编程方式回答 \"出了什么问题？\" 而不是仅仅说明 \"发生了一个问题\"  "
"（参见 PEP 3151，这是一个关于内置异常层次的例子）"

#: ../../pep-0008.txt:1165
msgid ""
"Class naming conventions apply here, although you should add the suffix "
"\"Error\" to your exception classes if the exception is an error.  Non-"
"error exceptions that are used for non-local flow control or other forms "
"of signaling need no special suffix."
msgstr ""
"类的命名惯例适用于此，尽管如果异常是一个错误，你应该给你的异常类添加后缀 \"Error\"。"
"用于非本地流控制或其他形式的信号的非错误异常不需要特殊的后缀。"

#: ../../pep-0008.txt:1170
msgid ""
"Use exception chaining appropriately. ``raise X from Y`` should be used "
"to indicate explicit replacement without losing the original traceback."
msgstr ""
"适当地使用异常链。 ``raise X from Y`` 应该被用来表示显式替换，而不丢失原始回溯。"

#: ../../pep-0008.txt:1174
msgid ""
"When deliberately replacing an inner exception (using ``raise X from "
"None``), ensure that relevant details are transferred to the new "
"exception (such as preserving the attribute name when converting KeyError"
" to AttributeError, or embedding the text of the original exception in "
"the new exception message)."
msgstr ""
"当故意替换一个内部异常时（使用 ``raise X from None``），"
"确保相关的细节被转移到新的异常中"
"（比如在将 KeyError 转换为 AttributeError 时保留属性名称，或者在新的异常消息中嵌入原始异常的文本）。"

#: ../../pep-0008.txt:1180
msgid ""
"When catching exceptions, mention specific exceptions whenever possible "
"instead of using a bare ``except:`` clause::"
msgstr ""
"在捕获异常时，尽可能提到具体的异常，而不是使用赤裸裸的 ``except:`` 子句 ::"

#: ../../pep-0008.txt:1188
msgid ""
"A bare ``except:`` clause will catch SystemExit and KeyboardInterrupt "
"exceptions, making it harder to interrupt a program with Control-C, and "
"can disguise other problems.  If you want to catch all exceptions that "
"signal program errors, use ``except Exception:`` (bare except is "
"equivalent to ``except BaseException:``)."
msgstr ""
"裸漏的 ``except:`` 子句会捕捉 SystemExit 和 KeyboardInterrupt 异常，"
"使得用 Control-C 中断程序更加困难，并且可以掩盖其他问题。"
"如果你想捕捉所有提示程序错误的异常，请使用 ``except Exception:``（裸 except 相当于 ``except BaseException:``）。"

#: ../../pep-0008.txt:1195
msgid ""
"A good rule of thumb is to limit use of bare 'except' clauses to two "
"cases:"
msgstr ""
"一个好的经验法则是，将裸露的 'except' 子句的使用限制在两种情况下："

#: ../../pep-0008.txt:1198
msgid ""
"If the exception handler will be printing out or logging the traceback; "
"at least the user will be aware that an error has occurred."
msgstr ""
"如果异常处理程序将打印出来或记录回溯；至少用户会意识到发生了错误。"

#: ../../pep-0008.txt:1202
msgid ""
"If the code needs to do some cleanup work, but then lets the exception "
"propagate upwards with ``raise``.  ``try...finally`` can be a better way "
"to handle this case."
msgstr ""
"如果代码需要做一些清理工作，但又让异常通过 ``raise`` 向上传播。``try...finally`` 可以是处理这种情况的更好方法。"

#: ../../pep-0008.txt:1206
msgid ""
"When catching operating system errors, prefer the explicit exception "
"hierarchy introduced in Python 3.3 over introspection of ``errno`` "
"values."
msgstr ""
"当捕捉操作系统错误时，更喜欢 Python 3.3 中引入的显式异常层次，而不是对 ``errno`` 值的自省。"

#: ../../pep-0008.txt:1210
msgid ""
"Additionally, for all try/except clauses, limit the ``try`` clause to the"
" absolute minimum amount of code necessary.  Again, this avoids masking "
"bugs::"
msgstr ""
"此外，对于所有的 try/except 子句，将 ``try`` 子句限制在必要的绝对最小的代码量。同样，这也避免了掩盖错误 ::"。

#: ../../pep-0008.txt:1232
msgid ""
"When a resource is local to a particular section of code, use a ``with`` "
"statement to ensure it is cleaned up promptly and reliably after use. A "
"try/finally statement is also acceptable."
msgstr ""
"当一个资源是某段代码的局部时，使用 ``with`` 语句来确保它在使用后被及时可靠地清理掉。try/finally 语句也是可以接受的。"

#: ../../pep-0008.txt:1236
msgid ""
"Context managers should be invoked through separate functions or methods "
"whenever they do something other than acquire and release resources::"
msgstr ""
"上下文管理程序除了获取和释放资源外，还应该通过单独的函数或方法来调用 ::"

#: ../../pep-0008.txt:1249
msgid ""
"The latter example doesn't provide any information to indicate that the "
"``__enter__`` and ``__exit__`` methods are doing something other than "
"closing the connection after a transaction.  Being explicit is important "
"in this case."
msgstr ""
"后一个例子没有提供任何信息来表明 ``__enter__`` 和 ``__exit__`` 方法除了在连接后关闭连接外，还在做其他事情。"
"在这种情况下，明确说明是很重要的。"

#: ../../pep-0008.txt:1254
msgid ""
"Be consistent in return statements.  Either all return statements in a "
"function should return an expression, or none of them should.  If any "
"return statement returns an expression, any return statements where no "
"value is returned should explicitly state this as ``return None``, and an"
" explicit return statement should be present at the end of the function "
"(if reachable)::"
msgstr ""
"在返回语句中要保持一致。在一个函数中，要么所有的返回语句都应该返回一个表达式，要么都不应该。"
"如果任何返回语句都返回一个表达式，任何没有返回值的返回语句都应该明确说明为 ``return None``，"
"并且在函数的末尾应该有一个明确的返回语句（如果可以达到） ::"

#: ../../pep-0008.txt:1287
msgid ""
"Use ``''.startswith()`` and ``''.endswith()`` instead of string slicing "
"to check for prefixes or suffixes."
msgstr ""
"使用 ``''.startswith()`` 和 ``''.endswith()`` 代替字符串切分来检查前缀或后缀。"

#: ../../pep-0008.txt:1290
msgid "startswith() and endswith() are cleaner and less error prone::"
msgstr "startswith() 和 endswith() 更干净，更不容易出错 ::"

#: ../../pep-0008.txt:1300
msgid ""
"Object type comparisons should always use isinstance() instead of "
"comparing types directly::"
msgstr ""
"对象类型比较应该总是使用 isinstance()，而不是直接比较类型 ::"

#: ../../pep-0008.txt:1311
msgid ""
"For sequences, (strings, lists, tuples), use the fact that empty "
"sequences are false::"
msgstr ""
"对于序列，（字符串、列表、元组），使用空序列为 false 的事实 ::"

#: ../../pep-0008.txt:1324
msgid ""
"Don't write string literals that rely on significant trailing whitespace."
"  Such trailing whitespace is visually indistinguishable and some editors"
" (or more recently, reindent.py) will trim them."
msgstr ""
"不要写依赖大量尾部空白的字符串字面。"
"这样的尾部空白在视觉上是无法区分的，一些编辑器（或最近的 reindent.py）会修剪它们。"

#: ../../pep-0008.txt:1328
msgid "Don't compare boolean values to True or False using ``==``::"
msgstr "不要用 ``==`` 来比较布尔值是真还是假 ::"

#: ../../pep-0008.txt:1338
msgid "Worse::"
msgstr "更糟糕的是 ::"

#: ../../pep-0008.txt:1343
msgid ""
"Use of the flow control statements ``return``/``break``/``continue`` "
"within the finally suite of a ``try...finally``, where the flow control "
"statement would jump outside the finally suite, is discouraged.  This is "
"because such statements will implicitly cancel any active exception that "
"is propagating through the finally suite::"
msgstr ""
"不鼓励在 ``try...finally`` 的 finally 套件中使用流程控制语句 ``return``/``break``/``continue``，"
"因为流程控制语句会跳出 finally 套件。"
"这是因为这样的语句将隐含地取消任何正在通过 finally 套件传播的活动异常 ::"

#: ../../pep-0008.txt:1357
msgid "Function Annotations"
msgstr "函数注解"

#: ../../pep-0008.txt:1359
msgid ""
"With the acceptance of PEP 484, the style rules for function annotations "
"have changed."
msgstr ""
"随着 PEP 484 的接受，函数注解的风格规则已经改变。"

#: ../../pep-0008.txt:1362
msgid ""
"Function annotations should use PEP 484 syntax (There are some formatting"
" recommendations for annotations in the previous section)."
msgstr ""
"函数注解应该使用 PEP 484 语法（在前一节中有一些注解的格式建议）。"

#: ../../pep-0008.txt:1365
msgid ""
"The experimentation with annotation styles that was recommended "
"previously in this PEP is no longer encouraged."
msgstr ""
"不再鼓励以前在本 PEP 中推荐的注解样式的实验。"

#: ../../pep-0008.txt:1368
msgid ""
"However, outside the stdlib, experiments within the rules of PEP 484 are "
"now encouraged.  For example, marking up a large third party library or "
"application with PEP 484 style type annotations, reviewing how easy it "
"was to add those annotations, and observing whether their presence "
"increases code understandability."
msgstr ""
"然而，在 stdlib 之外，现在鼓励在 PEP 484 的规则内进行实验。"
"例如，用 PEP 484 风格的类型注解来标记一个大型的第三方库或应用程序，"
"审查添加这些注解有多容易，并观察它们的存在是否增加了代码的可理解性。"

#: ../../pep-0008.txt:1374
msgid ""
"The Python standard library should be conservative in adopting such "
"annotations, but their use is allowed for new code and for big "
"refactorings."
msgstr ""
"Python 标准库在采用这种注解时应该是保守的，但对于新的代码和大的重构来说，允许使用它们。"

#: ../../pep-0008.txt:1378
msgid ""
"For code that wants to make a different use of function annotations it is"
" recommended to put a comment of the form::"
msgstr ""
"对于想要对函数注解进行不同使用的代码，建议放一个形式为 ::"

#: ../../pep-0008.txt:1383
msgid ""
"near the top of the file; this tells type checkers to ignore all "
"annotations.  (More fine-grained ways of disabling complaints from type "
"checkers can be found in PEP 484.)"
msgstr ""
"靠近文件的顶部；这告诉类型检查器忽略所有的注释。"
"（禁用类型检查器投诉的更精细的方法可以在 PEP 484 中找到。）"

#: ../../pep-0008.txt:1387
msgid ""
"Like linters, type checkers are optional, separate tools.  Python "
"interpreters by default should not issue any messages due to type "
"checking and should not alter their behavior based on annotations."
msgstr ""
"就像 linter 一样，类型检查器是可选的、独立的工具。"
"默认情况下，Python 解释器不应该因为类型检查而发出任何消息，也不应该根据注解来改变它们的行为。"

#: ../../pep-0008.txt:1391
msgid ""
"Users who don't want to use type checkers are free to ignore them. "
"However, it is expected that users of third party library packages may "
"want to run type checkers over those packages.  For this purpose PEP 484 "
"recommends the use of stub files: .pyi files that are read by the type "
"checker in preference of the corresponding .py files. Stub files can be "
"distributed with a library, or separately (with the library author's "
"permission) through the typeshed repo [5]_."
msgstr ""
"不想使用类型检查器的用户可以自由地忽略它们。"
"然而，预计第三方库包的用户可能想要在这些包上运行类型检查器。"
"为此，PEP 484 推荐使用存根文件（stub files）："
"类型检查器优先读取的 .pyi 文件，而不是相应的 .py 文件。"
"存根文件可以与库一起发布，也可以通过 typeshed 仓库 [5]_ 单独发布（得到库作者的许可）。"

#: ../../pep-0008.txt:1401
msgid "Variable Annotations"
msgstr "变量注解"

#: ../../pep-0008.txt:1403
msgid ""
"PEP 526 introduced variable annotations. The style recommendations for "
"them are similar to those on function annotations described above:"
msgstr ""
"PEP 526 引入了变量注释。对它们的风格建议与上述关于函数注释的建议相似："

#: ../../pep-0008.txt:1406
msgid ""
"Annotations for module level variables, class and instance variables, and"
" local variables should have a single space after the colon."
msgstr ""
"模块级变量、类和实例变量以及局部变量的注释应该在冒号后面有一个空格。"

#: ../../pep-0008.txt:1409
msgid "There should be no space before the colon."
msgstr "冒号前不应该有空格。"

#: ../../pep-0008.txt:1411
msgid ""
"If an assignment has a right hand side, then the equality sign should "
"have exactly one space on both sides::"
msgstr ""
"如果一个赋值有一个右侧，那么等号符号两边应该正好有一个空格 ::"

#: ../../pep-0008.txt:1432
msgid ""
"Although the PEP 526 is accepted for Python 3.6, the variable annotation "
"syntax is the preferred syntax for stub files on all versions of Python "
"(see PEP 484 for details)."
msgstr ""
"尽管 PEP 526 被接受用于 Python 3.6，但在所有版本的 Python 上，"
"变量注释语法是存根文件的首选语法（详见 PEP 484）。"

#: ../../pep-0008.txt:1437
msgid "Footnotes"
msgstr "脚注"

#: ../../pep-0008.txt:1438
msgid ""
"*Hanging indentation* is a type-setting style where all the lines in a "
"paragraph are indented except the first line.  In the context of Python, "
"the term is used to describe a style where the opening parenthesis of a "
"parenthesized statement is the last non-whitespace character of the line,"
" with subsequent lines being indented until the closing parenthesis."
msgstr ""
"*悬挂式缩进* 是一种类型设置风格，在一个段落中，除了第一行之外，所有的行都是缩进的。"
"在 Python 的上下文中，该术语用于描述这样一种风格："
"括号内语句的开头括号是该行的最后一个非空白字符，随后的几行一直缩进到结束括号。"

#: ../../pep-0008.txt:1447
msgid "References"
msgstr "参考"

#: ../../pep-0008.txt:1449
msgid "PEP 7, Style Guide for C Code, van Rossum"
msgstr ""

#: ../../pep-0008.txt:1451
msgid ""
"Barry's GNU Mailman style guide "
"http://barry.warsaw.us/software/STYLEGUIDE.txt"
msgstr ""

#: ../../pep-0008.txt:1454
msgid "Donald Knuth's *The TeXBook*, pages 195 and 196."
msgstr ""

#: ../../pep-0008.txt:1456
msgid "http://www.wikipedia.com/wiki/CamelCase"
msgstr ""

#: ../../pep-0008.txt:1458
msgid "Typeshed repo https://github.com/python/typeshed"
msgstr "typeshed 仓库 https://github.com/python/typeshed"

#: ../../pep-0008.txt:1464
msgid "Copyright"
msgstr "版权声明"

#: ../../pep-0008.txt:1466
msgid "This document has been placed in the public domain."
msgstr "本文档已被置于公共领域。"
