# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-31 09:39+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../pep-0692.rst
msgid "Author"
msgstr ""

#: ../../pep-0692.rst:3
msgid "Franek Magiera <framagie@gmail.com>"
msgstr ""

#: ../../pep-0692.rst
msgid "Sponsor"
msgstr ""

#: ../../pep-0692.rst:4
msgid "Jelle Zijlstra <jelle.zijlstra@gmail.com>"
msgstr ""

#: ../../pep-0692.rst
msgid "Discussions-To"
msgstr ""

#: ../../pep-0692.rst:5
msgid ""
"https://discuss.python.org/t/pep-692-using-typeddict-for-more-precise-"
"kwargs-typing/17314"
msgstr ""

#: ../../pep-0692.rst
msgid "Status"
msgstr ""

#: ../../pep-0692.rst:6
msgid "Draft"
msgstr ""

#: ../../pep-0692.rst
msgid "Type"
msgstr ""

#: ../../pep-0692.rst:7
msgid "Standards Track"
msgstr ""

#: ../../pep-0692.rst
msgid "Topic"
msgstr ""

#: ../../pep-0692.rst:8
msgid "Typing"
msgstr ""

#: ../../pep-0692.rst
msgid "Created"
msgstr ""

#: ../../pep-0692.rst:10
msgid "29-May-2022"
msgstr ""

#: ../../pep-0692.rst
msgid "Python-Version"
msgstr ""

#: ../../pep-0692.rst:11
msgid "3.12"
msgstr ""

#: ../../pep-0692.rst
msgid "Post-History"
msgstr ""

#: ../../pep-0692.rst:12
msgid ""
"`29-May-2022 <https://mail.python.org/archives/list/typing-"
"sig@python.org/thread/U42MJE6QZYWPVIFHJIGIT7OE52ZGIQV3/>`__, `12-Jul-2022"
" <https://mail.python.org/archives/list/python-"
"dev@python.org/thread/PLCNW2XR4OOKAKHEZQM7R2AYVYUXPZGW/>`__, `12-Jul-2022"
" <https://discuss.python.org/t/pep-692-using-typeddict-for-more-precise-"
"kwargs-typing/17314>`__,"
msgstr ""

#: ../../pep-0692.rst:18
msgid "Abstract"
msgstr ""

#: ../../pep-0692.rst:20
msgid ""
"Currently ``**kwargs`` can be type hinted as long as all of the keyword "
"arguments specified by them are of the same type. However, that behaviour"
" can be very limiting. Therefore, in this PEP we propose a new way to "
"enable more precise ``**kwargs`` typing. The new approach revolves around"
" using ``TypedDict`` to type ``**kwargs`` that comprise keyword arguments"
" of different types."
msgstr ""

#: ../../pep-0692.rst:30
msgid "Motivation"
msgstr ""

#: ../../pep-0692.rst:32
msgid ""
"Currently annotating ``**kwargs`` with a type ``T`` means that the "
"``kwargs`` type is in fact ``dict[str, T]``. For example::"
msgstr ""

#: ../../pep-0692.rst:37
msgid ""
"means that all keyword arguments in ``foo`` are strings (i.e., ``kwargs``"
" is of type ``dict[str, str]``). This behaviour limits the ability to "
"type annotate ``**kwargs`` only to the cases where all of them are of the"
" same type. However, it is often the case that keyword arguments conveyed"
" by ``**kwargs`` have different types that are dependent on the keyword's"
" name. In those cases type annotating ``**kwargs`` is not possible. This "
"is especially a problem for already existing codebases where the need of "
"refactoring the code in order to introduce proper type annotations may be"
" considered not worth the effort. This in turn prevents the project from "
"getting all of the benefits that type hinting can provide."
msgstr ""

#: ../../pep-0692.rst:48
msgid ""
"Moreover, ``**kwargs`` can be used to reduce the amount of code needed in"
" cases when there is a top-level function that is a part of a public API "
"and it calls a bunch of helper functions, all of which expect the same "
"keyword arguments. Unfortunately, if those helper functions were to use "
"``**kwargs``, there is no way to properly type hint them if the keyword "
"arguments they expect are of different types. In addition, even if the "
"keyword arguments are of the same type, there is no way to check whether "
"the function is being called with keyword names that it actually expects."
msgstr ""

#: ../../pep-0692.rst:57
msgid ""
"As described in the :ref:`Intended Usage <pep-692-intended-usage>` "
"section, using ``**kwargs`` is not always the best tool for the job. "
"Despite that, it is still a widely used pattern. As a consequence, there "
"has been a lot of discussion around supporting more precise ``**kwargs`` "
"typing and it became a feature that would be valuable for a large part of"
" the Python community. This is best illustrated by the `mypy GitHub issue"
" 4441 <mypyIssue4441_>`__ which contains a lot of real world cases that "
"could benefit from this propsal."
msgstr ""

#: ../../pep-0692.rst:65
msgid ""
"One more use case worth mentioning for which ``**kwargs`` are also "
"convenient, is when a function should accommodate optional keyword-only "
"arguments that don't have default values. A need for a pattern like that "
"can arise when values that are usually used as defaults to indicate no "
"user input, such as ``None``, can be passed in by a user and should "
"result in a valid, non-default behavior. For example, this issue `came up"
" <httpxIssue1384_>`__ in the popular ``httpx`` library."
msgstr ""

#: ../../pep-0692.rst:75
msgid "Rationale"
msgstr ""

#: ../../pep-0692.rst:77
msgid ""
":pep:`589` introduced the ``TypedDict`` type constructor that supports "
"dictionary types consisting of string keys and values of potentially "
"different types. A function's keyword arguments represented by a formal "
"parameter that begins with double asterisk, such as ``**kwargs``, are "
"received as a dictionary. Additionally, such functions are often called "
"using unpacked dictionaries to provide keyword arguments. This makes "
"``TypedDict`` a perfect candidate to be used for more precise "
"``**kwargs`` typing. In addition, with ``TypedDict`` keyword names can be"
" taken into account during static type analysis. However, specifying "
"``**kwargs`` type with a ``TypedDict`` means, as mentioned earlier, that "
"each keyword argument specified by ``**kwargs`` is a ``TypedDict`` "
"itself. For instance::"
msgstr ""

#: ../../pep-0692.rst:95
msgid ""
"means that each keyword argument in ``foo`` is itself a ``Movie`` "
"dictionary that has a ``name`` key with a string type value and a "
"``year`` key with an integer type value. Therefore, in order to support "
"specifying ``kwargs`` type as a ``TypedDict`` without breaking current "
"behaviour, a new construct has to be introduced."
msgstr ""

#: ../../pep-0692.rst:101
msgid ""
"To support this use case, we propose reusing ``Unpack`` which was "
"initially introduced in :pep:`646`. There are several reasons for doing "
"so:"
msgstr ""

#: ../../pep-0692.rst:104
msgid ""
"Its name is quite suitable and intuitive for the ``**kwargs`` typing use "
"case as our intention is to \"unpack\" the keywords arguments from the "
"supplied ``TypedDict``."
msgstr ""

#: ../../pep-0692.rst:107
msgid ""
"The current way of typing ``*args`` would be extended to ``**kwargs`` and"
" those are supposed to behave similarly."
msgstr ""

#: ../../pep-0692.rst:109
msgid "There would be no need to introduce any new special forms."
msgstr ""

#: ../../pep-0692.rst:110
msgid ""
"The use of ``Unpack`` for the purposes described in this PEP does not "
"interfere with the use cases described in :pep:`646`."
msgstr ""

#: ../../pep-0692.rst:114
msgid "Specification"
msgstr ""

#: ../../pep-0692.rst:116
msgid ""
"With ``Unpack`` we introduce a new way of annotating ``**kwargs``. "
"Continuing the previous example::"
msgstr ""

#: ../../pep-0692.rst:121
msgid ""
"would mean that the ``**kwargs`` comprise two keyword arguments specified"
" by ``Movie`` (i.e. a ``name`` keyword of type ``str`` and a ``year`` "
"keyword of type ``int``). This indicates that the function should be "
"called as follows::"
msgstr ""

#: ../../pep-0692.rst:130
msgid ""
"When ``Unpack`` is used, type checkers treat ``kwargs`` inside the "
"function body as a ``TypedDict``::"
msgstr ""

#: ../../pep-0692.rst:137
msgid ""
"Using the new annotation will not have any runtime effect - it should "
"only be taken into account by type checkers. Any mention of errors in the"
" following sections relates to type checker errors."
msgstr ""

#: ../../pep-0692.rst:142
msgid "Function calls with standard dictionaries"
msgstr ""

#: ../../pep-0692.rst:144
msgid ""
"Passing a dictionary of type ``dict[str, object]`` as a ``**kwargs`` "
"argument to a function that has ``**kwargs`` annotated with ``Unpack`` "
"must generate a type checker error. On the other hand, the behaviour for "
"functions using standard, untyped dictionaries can depend on the type "
"checker. For example::"
msgstr ""

#: ../../pep-0692.rst:161
msgid "Keyword collisions"
msgstr ""

#: ../../pep-0692.rst:163
msgid ""
"A ``TypedDict`` that is used to type ``**kwargs`` could potentially "
"contain keys that are already defined in the function's signature. If the"
" duplicate name is a standard parameter, an error should be reported by "
"type checkers. If the duplicate name is a positional-only parameter, no "
"errors should be generated. For example::"
msgstr ""

#: ../../pep-0692.rst:179
msgid "Required and non-required keys"
msgstr ""

#: ../../pep-0692.rst:181
msgid ""
"By default all keys in a ``TypedDict`` are required. This behaviour can "
"be overridden by setting the dictionary's ``total`` parameter as "
"``False``. Moreover, :pep:`655` introduced new type qualifiers - "
"``typing.Required`` and ``typing.NotRequired`` - that enable specifying "
"whether a particular key is required or not::"
msgstr ""

#: ../../pep-0692.rst:191
msgid ""
"When using a ``TypedDict`` to type ``**kwargs`` all of the required and "
"non-required keys should correspond to required and non-required function"
" keyword parameters. Therefore, if a required key is not supported by the"
" caller, then an error must be reported by type checkers."
msgstr ""

#: ../../pep-0692.rst:197
msgid "Assignment"
msgstr ""

#: ../../pep-0692.rst:199
msgid ""
"Assignments of a function typed with ``**kwargs: Unpack[Movie]`` and "
"another callable type should pass type checking only if they are "
"compatible. This can happen for the scenarios described below."
msgstr ""

#: ../../pep-0692.rst:204
msgid "Source and destination contain ``**kwargs``"
msgstr ""

#: ../../pep-0692.rst:206
msgid ""
"Both destination and source functions have a ``**kwargs: "
"Unpack[TypedDict]`` parameter and the destination function's "
"``TypedDict`` is assignable to the source function's ``TypedDict`` and "
"the rest of the parameters are compatible::"
msgstr ""

#: ../../pep-0692.rst:229
msgid "Source contains ``**kwargs`` and destination doesn't"
msgstr ""

#: ../../pep-0692.rst:231
msgid ""
"The destination callable doesn't contain ``**kwargs``, the source "
"callable contains ``**kwargs: Unpack[TypedDict]`` and the destination "
"function's keyword arguments are assignable to the corresponding keys in "
"source function's ``TypedDict``. Moreover, not required keys should "
"correspond to optional function arguments, whereas required keys should "
"correspond to required function arguments. Again, the rest of the "
"parameters have to be compatible. Continuing the previous example::"
msgstr ""

#: ../../pep-0692.rst:249
msgid ""
"It is worth pointing out that the destination function's parameters that "
"are to be compatible with the keys and values from the ``TypedDict`` must"
" be keyword only::"
msgstr ""

#: ../../pep-0692.rst:260
msgid ""
"The reverse situation where the destination callable contains ``**kwargs:"
" Unpack[TypedDict]`` and the source callable doesn't contain ``**kwargs``"
" should be disallowed. This is because, we cannot be sure that additional"
" keyword arguments are not being passed in when an instance of a subclass"
" had been assigned to a variable with a base class type and then unpacked"
" in the destination callable invocation::"
msgstr ""

#: ../../pep-0692.rst:276
msgid ""
"Similar situation can happen even without inheritance as compatibility "
"between ``TypedDict``\\s is based on structural subtyping."
msgstr ""

#: ../../pep-0692.rst:280
msgid "Source contains untyped ``**kwargs``"
msgstr ""

#: ../../pep-0692.rst:282
msgid ""
"The destination callable contains ``**kwargs: Unpack[TypedDict]`` and the"
" source callable contains untyped ``**kwargs``::"
msgstr ""

#: ../../pep-0692.rst:291
msgid "Source contains traditionally typed ``**kwargs: T``"
msgstr ""

#: ../../pep-0692.rst:293
msgid ""
"The destination callable contains ``**kwargs: Unpack[TypedDict]``, the "
"source callable contains traditionally typed ``**kwargs: T`` and each of "
"the destination function ``TypedDict``'s fields is assignable to a "
"variable of type ``T``::"
msgstr ""

#: ../../pep-0692.rst:316
msgid ""
"On the other hand, if the destination callable contains either untyped or"
" traditionally typed ``**kwargs: T`` and the source callable is typed "
"using ``**kwargs: Unpack[TypedDict]`` then an error should be generated, "
"because traditionally typed ``**kwargs`` aren't checked for keyword "
"names."
msgstr ""

#: ../../pep-0692.rst:321
msgid ""
"To summarize, function parameters should behave contravariantly and "
"function return types should behave covariantly."
msgstr ""

#: ../../pep-0692.rst:325
msgid "Passing kwargs inside a function to another function"
msgstr ""

#: ../../pep-0692.rst:327
msgid ""
":ref:`A previous point <pep-692-assignment-dest-no-kwargs>` mentions the "
"problem of possibly passing additional keyword arguments by assigning a "
"subclass instance to a variable that has a base class type. Let's "
"consider the following example::"
msgstr ""

#: ../../pep-0692.rst:363
msgid ""
"In the example above, the call to ``foo`` will not cause any issues at "
"runtime. Even though ``foo`` expects ``kwargs`` of type ``Animal`` it "
"doesn't matter if it receives additional arguments because it only reads "
"and uses what it needs completely ignoring any additional values."
msgstr ""

#: ../../pep-0692.rst:368
msgid ""
"The calls to ``bar`` and ``spam`` will fail because an unexpected keyword"
" argument will be passed to the ``takes_name`` function."
msgstr ""

#: ../../pep-0692.rst:371
msgid ""
"Therefore, ``kwargs`` hinted with an unpacked ``TypedDict`` can only be "
"passed to another function if the function to which unpacked kwargs are "
"being passed to has ``**kwargs`` in its signature as well, because then "
"additional keywords would not cause errors at runtime during function "
"invocation. Otherwise, the type checker should generate an error."
msgstr ""

#: ../../pep-0692.rst:377
msgid ""
"In cases similar to the ``bar`` function above the problem could be "
"worked around by explicitly dereferencing desired fields and using them "
"as arguments to perform the function call::"
msgstr ""

#: ../../pep-0692.rst:386
msgid "Using ``Unpack`` with types other than ``TypedDict``"
msgstr ""

#: ../../pep-0692.rst:388
msgid ""
"As described in the :ref:`Rationale <pep-692-rationale>` section, "
"``TypedDict`` is the most natural candidate for typing ``**kwargs``. "
"Therefore, in the context of typing ``**kwargs``, using ``Unpack`` with "
"types other than ``TypedDict`` should not be allowed and type checkers "
"should generate errors in such cases."
msgstr ""

#: ../../pep-0692.rst:395
msgid "Changes to ``Unpack``"
msgstr ""

#: ../../pep-0692.rst:397
msgid ""
"Currently using ``Unpack`` in the context of typing is interchangeable "
"with using the asterisk syntax::"
msgstr ""

#: ../../pep-0692.rst:403
msgid ""
"Therefore, in order to be compatible with the new use case, ``Unpack``'s "
"``repr`` should be changed to simply ``Unpack[T]``."
msgstr ""

#: ../../pep-0692.rst:409
msgid "Intended Usage"
msgstr ""

#: ../../pep-0692.rst:410
msgid ""
"The intended use cases for this proposal are described in the "
":ref:`pep-692-motivation` section. In summary, more precise ``**kwargs`` "
"typing can bring benefits to already existing codebases that decided to "
"use ``**kwargs`` initially, but now are mature enough to use a stricter "
"contract via type hints. Using ``**kwargs`` can also help in reducing "
"code duplication and the amount of copy-pasting needed when there is a "
"bunch of functions that require the same set of keyword arguments. "
"Finally, ``**kwargs`` are useful for cases when a function needs to "
"facilitate optional keyword arguments that don't have obvious default "
"values."
msgstr ""

#: ../../pep-0692.rst:420
msgid ""
"However, it has to be pointed out that in some cases there are better "
"tools for the job than using ``TypedDict`` to type ``**kwargs`` as "
"proposed in this PEP. For example, when writing new code if all the "
"keyword arguments are required or have default values then writing "
"everything explicitly is better than using ``**kwargs`` and a "
"``TypedDict``::"
msgstr ""

#: ../../pep-0692.rst:429
msgid ""
"Similarly, when type hinting third party libraries via stubs it is again "
"better to state the function signature explicitly - this is the only way "
"to type such a function if it has default arguments. Another issue that "
"may arise in this case when trying to type hint the function with a "
"``TypedDict`` is that some standard function parameters may be treated as"
" keyword only::"
msgstr ""

#: ../../pep-0692.rst:446
msgid ""
"Therefore, in this case it is again preferred to type hint such function "
"explicitly as::"
msgstr ""

#: ../../pep-0692.rst:451
msgid ""
"Also, for the benefit of IDEs and documentation pages, functions that are"
" part of the public API should prefer explicit keyword parameters "
"whenever possible."
msgstr ""

#: ../../pep-0692.rst:455
msgid "How to Teach This"
msgstr ""

#: ../../pep-0692.rst:457
msgid ""
"This PEP could be linked in the ``typing`` module's documentation. "
"Moreover, a new section on using ``Unpack`` could be added to the "
"aforementioned docs. Similar sections could be also added to the `mypy "
"documentation <https://mypy.readthedocs.io/>`_ and the `typing RTD "
"documentation <https://typing.readthedocs.io/>`_."
msgstr ""

#: ../../pep-0692.rst:464
msgid "Reference Implementation"
msgstr ""

#: ../../pep-0692.rst:466
msgid ""
"The `mypy type checker <https://github.com/python/mypy>`_ already "
"`supports <https://github.com/python/mypy/pull/13471>`_ more precise "
"``**kwargs`` typing using ``Unpack``."
msgstr ""

#: ../../pep-0692.rst:470
msgid ""
"`Pyright type checker <https://github.com/microsoft/pyright>`_ also "
"`provides provisional support <pyrightProvisionalImplementation_>`__ for "
"`this feature <pyrightIssue3002_>`__."
msgstr ""

#: ../../pep-0692.rst:475
msgid "Rejected Ideas"
msgstr ""

#: ../../pep-0692.rst:478
msgid "``TypedDict`` unions"
msgstr ""

#: ../../pep-0692.rst:480
msgid ""
"It is possible to create unions of typed dictionaries. However, "
"supporting typing ``**kwargs`` with a union of typed dicts would greatly "
"increase the complexity of the implementation of this PEP and there seems"
" to be no compelling use case to justify the support for this. Therefore,"
" using unions of typed dictionaries to type ``**kwargs`` as described in "
"the context of this PEP can result in an error::"
msgstr ""

#: ../../pep-0692.rst:498
msgid ""
"Instead, a function that expects a union of ``TypedDict``\\s can be "
"overloaded::"
msgstr ""

#: ../../pep-0692.rst:508
msgid "Changing the meaning of ``**kwargs`` annotations"
msgstr ""

#: ../../pep-0692.rst:510
msgid ""
"One way to achieve the purpose of this PEP would be to change the meaning"
" of ``**kwargs`` annotations, so that the annotations would apply to the "
"entire ``**kwargs`` dict, not to individual elements. For consistency, we"
" would have to make an analogous change to ``*args`` annotations."
msgstr ""

#: ../../pep-0692.rst:516
msgid ""
"This idea was discussed in a meeting of the typing community, and the "
"consensus was that the change would not be worth the cost. There is no "
"clear migration path, the current meaning of ``*args`` and ``**kwargs`` "
"annotations is well-established in the ecosystem, and type checkers would"
" have to introduce new errors for code that is currently legal."
msgstr ""

#: ../../pep-0692.rst:523
msgid "Introducing a new syntax"
msgstr ""

#: ../../pep-0692.rst:525
msgid ""
"In the previous versions of this PEP, using a double asterisk syntax was "
"proposed to support more precise ``**kwargs`` typing. Using this syntax, "
"functions could be annotated as follows::"
msgstr ""

#: ../../pep-0692.rst:531
msgid "Which would have the same meaning as::"
msgstr ""

#: ../../pep-0692.rst:535
msgid ""
"This greatly increased the scope of the PEP, as it would require a "
"grammar change and adding a new dunder for the ``Unpack`` special form. "
"At the same the justification for introducing a new syntax was not strong"
" enough and became a blocker for the whole PEP. Therefore, we decided to "
"abandon the idea of introducing a new syntax as a part of this PEP and "
"may propose it again in a separate one."
msgstr ""

#: ../../pep-0692.rst:551
msgid "Copyright"
msgstr ""

#: ../../pep-0692.rst:553
msgid ""
"This document is placed in the public domain or under the "
"CC0-1.0-Universal license, whichever is more permissive."
msgstr ""

