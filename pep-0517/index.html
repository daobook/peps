
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 517 – A build-system independent format for source trees | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0517/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <meta name="description" content="Python Enhancement Proposals (PEPs)">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 517</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 517 – A build-system independent format for source trees</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Nathaniel J. Smith &lt;njs&#32;&#97;t&#32;pobox.com&gt;,
Thomas Kluyver &lt;thomas&#32;&#97;t&#32;kluyver.me.uk&gt;</dd>
<dt class="field-even">BDFL-Delegate<span class="colon">:</span></dt>
<dd class="field-even">Nick Coghlan &lt;ncoghlan&#32;&#97;t&#32;gmail.com&gt;</dd>
<dt class="field-odd">Discussions-To<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://mail.python.org/archives/list/distutils-sig&#64;python.org/">Distutils-SIG list</a></dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Accepted and implementation complete, or no longer active">Final</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Topic<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="../topic/packaging/">Packaging</a></dd>
<dt class="field-odd">Created<span class="colon">:</span></dt>
<dd class="field-odd">30-Sep-2015</dd>
<dt class="field-even">Post-History<span class="colon">:</span></dt>
<dd class="field-even">01-Oct-2015, 25-Oct-2015, 19-May-2017, 11-Sep-2017</dd>
<dt class="field-odd">Resolution<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://mail.python.org/pipermail/distutils-sig/2017-September/031548.html">Distutils-SIG message</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">摘要</a></li>
<li><a class="reference internal" href="#terminology-and-goals">术语和目标</a></li>
<li><a class="reference internal" href="#source-trees">源码树</a><ul>
<li><a class="reference internal" href="#build-requirements">构建需求</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-backend-interface">构建后端接口</a><ul>
<li><a class="reference internal" href="#mandatory-hooks">强制性的钩子</a><ul>
<li><a class="reference internal" href="#build-wheel">build_wheel</a></li>
<li><a class="reference internal" href="#build-sdist">build_sdist</a></li>
</ul>
</li>
<li><a class="reference internal" href="#optional-hooks">Optional hooks</a><ul>
<li><a class="reference internal" href="#get-requires-for-build-wheel">get_requires_for_build_wheel</a></li>
<li><a class="reference internal" href="#prepare-metadata-for-build-wheel">prepare_metadata_for_build_wheel</a></li>
<li><a class="reference internal" href="#get-requires-for-build-sdist">get_requires_for_build_sdist</a></li>
</ul>
</li>
<li><a class="reference internal" href="#config-settings">Config settings</a></li>
<li><a class="reference internal" href="#build-environment">Build environment</a><ul>
<li><a class="reference internal" href="#recommendations-for-build-frontends-non-normative">Recommendations for build frontends (non-normative)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#in-tree-build-backends">In-tree build backends</a></li>
</ul>
</li>
<li><a class="reference internal" href="#source-distributions">Source distributions</a></li>
<li><a class="reference internal" href="#evolutionary-notes">Evolutionary notes</a></li>
<li><a class="reference internal" href="#rejected-options">Rejected options</a></li>
<li><a class="reference internal" href="#summary-of-changes-to-pep-517">Summary of changes to PEP 517</a></li>
<li><a class="reference internal" href="#appendix-a-comparison-to-pep-516">Appendix A: Comparison to PEP 516</a><ul>
<li><a class="reference internal" href="#other-differences">Other differences</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">摘要</a></h2>
<p>虽然 <code class="docutils literal notranslate"><span class="pre">distutils</span></code> / <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> 已经带我们走了很长一段路，但它们有三个严重的问题：(a) 它们缺少重要的功能，比如可用的构建时依赖声明，自动配置，甚至基本的人体工程学细节，比如符合 <a class="reference external" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a> 的版本号管理，(b)扩展它们是困难的，所以虽然确实存在针对上述问题的各种解决方案，但它们通常是古怪的，脆弱的，维护成本昂贵，然而(c)很难使用其他任何东西，因为 distutils/setuptools 为安装用户和 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 等安装工具所需的包提供了标准接口。</p>
<p>以前的努力（例如 distutils2 或 setuptools 本身）试图解决问题(a)和/或(b)。这个提案旨在解决(c)。</p>
<p>这个 PEP 的目标是让 distutils-sig 不再充当 Python 构建系统的看门人。如果你想用 distutils，很好；如果您想使用其他方法，那么使用标准化方法应该很容易做到。与 distutils 进行接口的困难意味着目前还没有很多这样的系统，但是为了让我们了解我们正在考虑什么，请参阅 <a class="reference external" href="https://github.com/takluyver/flit">flit</a> 或 <a class="reference external" href="https://cournape.github.io/Bento/">bento</a>。幸运的是，wheels 现在已经解决了这里的许多难题——例如，构建系统不再需要知道可能的安装配置——所以真正需要的基本上就是构建系统能够以某种方式吐出符合标准的 wheels 和 sdist。</p>
<p>因此，建议为 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 等安装工具提供新的、相对最小的接口，以与包源代码树和源代码分发进行交互。</p>
</section>
<section id="terminology-and-goals">
<h2><a class="toc-backref" href="#terminology-and-goals" role="doc-backlink">术语和目标</a></h2>
<p>源代码树有点像 VCS 签出。需要标准的接口来从这种格式安装，以支持像 <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">some-directory/</span></code> 这样的用法。</p>
<p>源代码发行版（source distribution）是表示某些源代码的特定版本的静态快照，如 <code class="docutils literal notranslate"><span class="pre">lxml-3.4.4.tar.gz</span></code>。源代码发行版有很多用途：它们形成了版本的归档记录，它们为那些想要吸收和处理大量代码（可能用多种语言编写）的工具提供了一种笨拙而简单的事实上的标准，它们充当了下游打包系统（如 Debian/Fedora/Conda/…）的输入，等等。在 Python 生态系统中，它们还扮演着特别重要的角色，因为像 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 这样的打包工具能够使用源代码发行版来实现二进制依赖关系，例如，如果有发行版 <code class="docutils literal notranslate"><span class="pre">foo.whl</span></code> 声明了对 <code class="docutils literal notranslate"><span class="pre">bar</span></code> 的依赖，那么需要支持这样的情况，即 <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">bar</span></code> 或 <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">foo</span></code> 自动为 <code class="docutils literal notranslate"><span class="pre">bar</span></code> 定位 sdist，下载它，构建它，并安装结果包。</p>
<p>源代码发行版也简称为 <em>sdists</em>。</p>
<p><strong>构建前端</strong> （build frontend）是一种用户可以运行的工具，它可以获取任意的源代码树或源代码分布，并从中构建轮子。实际的构建由每个源树的 <strong>构建后端</strong> （build backend）完成。在像 <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">wheel</span> <span class="pre">some-directory/</span></code> 这样的命令中，<code class="docutils literal notranslate"><span class="pre">pip</span></code> 充当构建前端。</p>
<p><strong>集成前端</strong> （integration frontend）是用户可能运行的一种工具，它接受一组包需求（例如，requirements.txt 文件），并尝试更新工作环境以满足这些需求。这可能需要定位、构建和安装轮子和 sdist 的组合。在像 <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">lxml==2.4.0</span></code> 这样的命令中，pip 充当集成前端。”</p>
</section>
<section id="source-trees">
<h2><a class="toc-backref" href="#source-trees" role="doc-backlink">源码树</a></h2>
<p>有一个现有的、遗留的源代码树格式涉及 <code class="docutils literal notranslate"><span class="pre">setup.py</span></code>。我们不打算进一步详细说明；它的实际规范编码在 <code class="docutils literal notranslate"><span class="pre">distutils</span></code>、<code class="docutils literal notranslate"><span class="pre">setuptools</span></code>、<code class="docutils literal notranslate"><span class="pre">pip</span></code> 和其他工具的源代码和文档中。我们称之为 <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> 样式。</p>
<p>在这里，基于 <a class="pep reference internal" href="../pep-0518" title="PEP 518 – Specifying Minimum Build System Requirements for Python Projects">PEP 518</a> 中定义的 <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> 文件定义了一种新的源代码树样式，扩展了该文件中的 <code class="docutils literal notranslate"><span class="pre">[build-system]</span></code> 表，并添加了附加键 <code class="docutils literal notranslate"><span class="pre">build-backend</span></code>。下面是例子:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">build</span><span class="o">-</span><span class="n">system</span><span class="p">]</span>
<span class="c1"># Defined by PEP 518:</span>
<span class="n">requires</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;flit&quot;</span><span class="p">]</span>
<span class="c1"># Defined by this PEP:</span>
<span class="n">build</span><span class="o">-</span><span class="n">backend</span> <span class="o">=</span> <span class="s2">&quot;flit.api:main&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">build-backend</span></code> 是命名 Python 对象的字符串，该对象将用于执行构建(详细信息见下文)。它的格式遵循相同的 <code class="docutils literal notranslate"><span class="pre">module:object</span></code> 语法，作为 <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> 入口点。例如，如果字符串是 <code class="docutils literal notranslate"><span class="pre">&quot;flit.api:main&quot;</span></code> 就像上面的例子一样，这个对象将通过执行等价的命令来查找：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">flit.api</span>
<span class="n">backend</span> <span class="o">=</span> <span class="n">flit</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">main</span>
</pre></div>
</div>
<p>省略 <code class="docutils literal notranslate"><span class="pre">:object</span></code> 部分也是合法的，例如:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">build</span><span class="o">-</span><span class="n">backend</span> <span class="o">=</span> <span class="s2">&quot;flit.api&quot;</span>
</pre></div>
</div>
<p>它的作用如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">flit.api</span>
<span class="n">backend</span> <span class="o">=</span> <span class="n">flit</span><span class="o">.</span><span class="n">api</span>
</pre></div>
</div>
<p>形式上，字符串应该满足此语法:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>identifier = (letter | &#39;_&#39;) (letter | &#39;_&#39; | digit)*
module_path = identifier (&#39;.&#39; identifier)*
object_path = identifier (&#39;.&#39; identifier)*
entry_point = module_path (&#39;:&#39; object_path)?
</pre></div>
</div>
<p>我们导入 <code class="docutils literal notranslate"><span class="pre">module_path</span></code>，然后查找 <code class="docutils literal notranslate"><span class="pre">module_path.object_path</span></code> (如果缺少 <code class="docutils literal notranslate"><span class="pre">object_path</span></code>，则只需 <code class="docutils literal notranslate"><span class="pre">module_path</span></code>)。</p>
<p>当导入模块路径时，我们 <em>不会</em> 查看包含源树的目录，除非该目录位于 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> (例如，因为它是在 PYTHONPATH 中指定的)。尽管 Python 会自动将工作目录添加到 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>，在某些情况下，解析后端代码不应受此影响。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> 文件缺失，或者 <code class="docutils literal notranslate"><span class="pre">build-backend</span></code> 键缺失，则源树没有使用此规范，并且工具应该恢复到运行 <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> 的遗留行为(直接或隐式调用 <code class="docutils literal notranslate"><span class="pre">setuptools.build_meta:__legacy__</span></code> 后端)。</p>
<p>如果存在 <code class="docutils literal notranslate"><span class="pre">build-backend</span></code> 键，则该键优先，并且源树遵循指定后端的格式和约定(因此，除非后端需要，否则不需要 <code class="docutils literal notranslate"><span class="pre">setup.py</span></code>)。项目可能仍然希望包含 <code class="docutils literal notranslate"><span class="pre">setup.py</span></code>，以便与不使用此规范的工具兼容。</p>
<p>这个 PEP 还定义了 <code class="docutils literal notranslate"><span class="pre">backend-path</span></code> 键，用于 <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>，请参阅下面的 “树内构建后端” 部分。这个键的使用方式如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">build</span><span class="o">-</span><span class="n">system</span><span class="p">]</span>
<span class="c1"># Defined by PEP 518:</span>
<span class="n">requires</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;flit&quot;</span><span class="p">]</span>
<span class="c1"># Defined by this PEP:</span>
<span class="n">build</span><span class="o">-</span><span class="n">backend</span> <span class="o">=</span> <span class="s2">&quot;local_backend&quot;</span>
<span class="n">backend</span><span class="o">-</span><span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;backend&quot;</span><span class="p">]</span>
</pre></div>
</div>
<section id="build-requirements">
<h3><a class="toc-backref" href="#build-requirements" role="doc-backlink">构建需求</a></h3>
<p>这个 PEP 在 <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> 的“构建需求”部分放置了许多额外的需求。这些旨在确保项目不会创造不可能满足其建造要求的条件。</p>
<ul class="simple">
<li>项目构建需求将定义有向的需求图（项目 A 需要 B 来构建，B 需要 C 和 D，等等）这个图一定不能包含循环。如果（例如，由于项目之间缺乏协调）存在周期，前端可能会拒绝构建项目。</li>
<li>当构建需求作为轮子可用时，前端应该在实际的地方使用它们，以避免深度嵌套的构建。然而，前端可能有一种模式，在定位构建需求时不考虑轮子，因此项目一定不要认为发布轮子就足以打破需求循环。</li>
<li>前端应该明确地检查需求周期，如果发现需求周期，就用有信息的消息终止构建。</li>
</ul>
<p>特别要注意的是，没有需求循环的要求意味着希望自托管的后端（即，为后端构建轮子使用该后端进行构建）需要做出特殊的规定，以避免造成循环。通常，这将涉及将自己指定为树内后端，并避免外部构建依赖(通常通过提供它们)。</p>
</section>
</section>
<section id="build-backend-interface">
<h2><a class="toc-backref" href="#build-backend-interface" role="doc-backlink">构建后端接口</a></h2>
<p>构建后端对象期望具有提供以下部分或全部钩子的属性。常见的 <code class="docutils literal notranslate"><span class="pre">config_settings</span></code> 参数在各个钩子之后描述。</p>
<section id="mandatory-hooks">
<h3><a class="toc-backref" href="#mandatory-hooks" role="doc-backlink">强制性的钩子</a></h3>
<section id="build-wheel">
<h4><a class="toc-backref" href="#build-wheel" role="doc-backlink">build_wheel</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">build_wheel</span><span class="p">(</span><span class="n">wheel_directory</span><span class="p">,</span> <span class="n">config_settings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metadata_directory</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>必须构建 .whl 文件，并将其放在指定的 <code class="docutils literal notranslate"><span class="pre">wheel_directory</span></code> 中。它必须返回 <code class="docutils literal notranslate"><span class="pre">.whl</span></code>  的基名(而不是完整路径)，作为 unicode 字符串。</p>
<p>If the build frontend has previously called <code class="docutils literal notranslate"><span class="pre">prepare_metadata_for_build_wheel</span></code>
and depends on the wheel resulting from this call to have metadata
matching this earlier call, then it should provide the path to the created
<code class="docutils literal notranslate"><span class="pre">.dist-info</span></code> directory as the <code class="docutils literal notranslate"><span class="pre">metadata_directory</span></code> argument. If this
argument is provided, then <code class="docutils literal notranslate"><span class="pre">build_wheel</span></code> MUST produce a wheel with identical
metadata. The directory passed in by the build frontend MUST be
identical to the directory created by <code class="docutils literal notranslate"><span class="pre">prepare_metadata_for_build_wheel</span></code>,
including any unrecognized files it created.</p>
<p>Backends which do not provide the <code class="docutils literal notranslate"><span class="pre">prepare_metadata_for_build_wheel</span></code> hook may
either silently ignore the <code class="docutils literal notranslate"><span class="pre">metadata_directory</span></code> parameter to <code class="docutils literal notranslate"><span class="pre">build_wheel</span></code>,
or else raise an exception when it is set to anything other than <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>To ensure that wheels from different sources are built the same way, frontends
may call <code class="docutils literal notranslate"><span class="pre">build_sdist</span></code> first, and then call <code class="docutils literal notranslate"><span class="pre">build_wheel</span></code> in the unpacked
sdist. But if the backend indicates that it is missing some requirements for
creating an sdist (see below), the frontend will fall back to calling
<code class="docutils literal notranslate"><span class="pre">build_wheel</span></code> in the source directory.</p>
<p>The source directory may be read-only. Backends should therefore be
prepared to build without creating or modifying any files in the source
directory, but they may opt not to handle this case, in which case
failures will be visible to the user. Frontends are not responsible for
any special handling of read-only source directories.</p>
<p>The backend may store intermediate artifacts in cache locations or
temporary directories. The presence or absence of any caches should not
make a material difference to the final result of the build.</p>
</section>
<section id="build-sdist">
<h4><a class="toc-backref" href="#build-sdist" role="doc-backlink">build_sdist</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">build_sdist</span><span class="p">(</span><span class="n">sdist_directory</span><span class="p">,</span> <span class="n">config_settings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Must build a .tar.gz source distribution and place it in the specified
<code class="docutils literal notranslate"><span class="pre">sdist_directory</span></code>. It must return the basename (not the full path) of the
<code class="docutils literal notranslate"><span class="pre">.tar.gz</span></code> file it creates, as a unicode string.</p>
<p>A .tar.gz source distribution (sdist) contains a single top-level directory called
<code class="docutils literal notranslate"><span class="pre">{name}-{version}</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">foo-1.0</span></code>), containing the source files of the
package. This directory must also contain the
<code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> from the build directory, and a PKG-INFO file containing
metadata in the format described in
<a class="pep reference internal" href="../pep-0345" title="PEP 345 – Metadata for Python Software Packages 1.2">PEP 345</a>. Although historically
zip files have also been used as sdists, this hook should produce a gzipped
tarball. This is already the more common format for sdists, and having a
consistent format makes for simpler tooling.</p>
<p>The generated tarball should use the modern POSIX.1-2001 pax tar format, which
specifies UTF-8 based file names. This is not yet the default for the tarfile
module shipped with Python 3.6, so backends using the tarfile module need to
explicitly pass <code class="docutils literal notranslate"><span class="pre">format=tarfile.PAX_FORMAT</span></code>.</p>
<p>Some backends may have extra requirements for creating sdists, such as version
control tools. However, some frontends may prefer to make intermediate sdists
when producing wheels, to ensure consistency.
If the backend cannot produce an sdist because a dependency is missing, or
for another well understood reason, it should raise an exception of a specific
type which it makes available as <code class="docutils literal notranslate"><span class="pre">UnsupportedOperation</span></code> on the backend object.
If the frontend gets this exception while building an sdist as an intermediate
for a wheel, it should fall back to building a wheel directly.
The backend does not need to define this exception type if it would never raise
it.</p>
</section>
</section>
<section id="optional-hooks">
<h3><a class="toc-backref" href="#optional-hooks" role="doc-backlink">Optional hooks</a></h3>
<section id="get-requires-for-build-wheel">
<h4><a class="toc-backref" href="#get-requires-for-build-wheel" role="doc-backlink">get_requires_for_build_wheel</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_requires_for_build_wheel</span><span class="p">(</span><span class="n">config_settings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>This hook MUST return an additional list of strings containing <a class="pep reference internal" href="../pep-0508" title="PEP 508 – Dependency specification for Python Software Packages">PEP 508</a>
dependency specifications, above and beyond those specified in the
<code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> file, to be installed when calling the <code class="docutils literal notranslate"><span class="pre">build_wheel</span></code> or
<code class="docutils literal notranslate"><span class="pre">prepare_metadata_for_build_wheel</span></code> hooks.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_requires_for_build_wheel</span><span class="p">(</span><span class="n">config_settings</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;wheel &gt;= 0.25&quot;</span><span class="p">,</span> <span class="s2">&quot;setuptools&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>If not defined, the default implementation is equivalent to <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">[]</span></code>.</p>
</section>
<section id="prepare-metadata-for-build-wheel">
<h4><a class="toc-backref" href="#prepare-metadata-for-build-wheel" role="doc-backlink">prepare_metadata_for_build_wheel</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">prepare_metadata_for_build_wheel</span><span class="p">(</span><span class="n">metadata_directory</span><span class="p">,</span> <span class="n">config_settings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Must create a <code class="docutils literal notranslate"><span class="pre">.dist-info</span></code> directory containing wheel metadata
inside the specified <code class="docutils literal notranslate"><span class="pre">metadata_directory</span></code> (i.e., creates a directory
like <code class="docutils literal notranslate"><span class="pre">{metadata_directory}/{package}-{version}.dist-info/</span></code>). This
directory MUST be a valid <code class="docutils literal notranslate"><span class="pre">.dist-info</span></code> directory as defined in the
wheel specification, except that it need not contain <code class="docutils literal notranslate"><span class="pre">RECORD</span></code> or
signatures. The hook MAY also create other files inside this
directory, and a build frontend MUST preserve, but otherwise ignore, such files;
the intention
here is that in cases where the metadata depends on build-time
decisions, the build backend may need to record these decisions in
some convenient format for re-use by the actual wheel-building step.</p>
<p>This must return the basename (not the full path) of the <code class="docutils literal notranslate"><span class="pre">.dist-info</span></code>
directory it creates, as a unicode string.</p>
<p>If a build frontend needs this information and the method is
not defined, it should call <code class="docutils literal notranslate"><span class="pre">build_wheel</span></code> and look at the resulting
metadata directly.</p>
</section>
<section id="get-requires-for-build-sdist">
<h4><a class="toc-backref" href="#get-requires-for-build-sdist" role="doc-backlink">get_requires_for_build_sdist</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_requires_for_build_sdist</span><span class="p">(</span><span class="n">config_settings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>This hook MUST return an additional list of strings containing <a class="pep reference internal" href="../pep-0508" title="PEP 508 – Dependency specification for Python Software Packages">PEP 508</a>
dependency specifications, above and beyond those specified in the
<code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> file. These dependencies will be installed when calling the
<code class="docutils literal notranslate"><span class="pre">build_sdist</span></code> hook.</p>
<p>If not defined, the default implementation is equivalent to <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">[]</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>Editable installs</p>
<p>This PEP originally specified another hook, <code class="docutils literal notranslate"><span class="pre">install_editable</span></code>, to do an
editable install (as with <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">-e</span></code>). It was removed due to the
complexity of the topic, but may be specified in a later PEP.</p>
<p>Briefly, the questions to be answered include: what reasonable ways existing
of implementing an ‘editable install’? Should the backend or the frontend
pick how to make an editable install? And if the frontend does, what does it
need from the backend to do so.</p>
</div>
</section>
</section>
<section id="config-settings">
<h3><a class="toc-backref" href="#config-settings" role="doc-backlink">Config settings</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">config_settings</span>
</pre></div>
</div>
<p>This argument, which is passed to all hooks, is an arbitrary
dictionary provided as an “escape hatch” for users to pass ad-hoc
configuration into individual package builds. Build backends MAY
assign any semantics they like to this dictionary. Build frontends
SHOULD provide some mechanism for users to specify arbitrary
string-key/string-value pairs to be placed in this dictionary. For
example, they might support some syntax like <code class="docutils literal notranslate"><span class="pre">--package-config</span>
<span class="pre">CC=gcc</span></code>. Build frontends MAY also provide arbitrary other mechanisms
for users to place entries in this dictionary. For example, <code class="docutils literal notranslate"><span class="pre">pip</span></code>
might choose to map a mix of modern and legacy command line arguments
like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span>                                           \
  <span class="o">--</span><span class="n">package</span><span class="o">-</span><span class="n">config</span> <span class="n">CC</span><span class="o">=</span><span class="n">gcc</span>                             \
  <span class="o">--</span><span class="k">global</span><span class="o">-</span><span class="n">option</span><span class="o">=</span><span class="s2">&quot;--some-global-option&quot;</span>              \
  <span class="o">--</span><span class="n">build</span><span class="o">-</span><span class="n">option</span><span class="o">=</span><span class="s2">&quot;--build-option1&quot;</span>                    \
  <span class="o">--</span><span class="n">build</span><span class="o">-</span><span class="n">option</span><span class="o">=</span><span class="s2">&quot;--build-option2&quot;</span>
</pre></div>
</div>
<p>into a <code class="docutils literal notranslate"><span class="pre">config_settings</span></code> dictionary like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
 <span class="s2">&quot;CC&quot;</span><span class="p">:</span> <span class="s2">&quot;gcc&quot;</span><span class="p">,</span>
 <span class="s2">&quot;--global-option&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;--some-global-option&quot;</span><span class="p">],</span>
 <span class="s2">&quot;--build-option&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;--build-option1&quot;</span><span class="p">,</span> <span class="s2">&quot;--build-option2&quot;</span><span class="p">],</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Of course, it’s up to users to make sure that they pass options which
make sense for the particular build backend and package that they are
building.</p>
<p>The hooks may be called with positional or keyword arguments, so backends
implementing them should be careful to make sure that their signatures match
both the order and the names of the arguments above.</p>
<p>All hooks are run with working directory set to the root of the source
tree, and MAY print arbitrary informational text on stdout and
stderr. They MUST NOT read from stdin, and the build frontend MAY
close stdin before invoking the hooks.</p>
<p>The build frontend may capture stdout and/or stderr from the backend. If the
backend detects that an output stream is not a terminal/console (e.g.
<code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">sys.stdout.isatty()</span></code>), it SHOULD ensure that any output it writes to that
stream is UTF-8 encoded. The build frontend MUST NOT fail if captured output is
not valid UTF-8, but it MAY not preserve all the information in that case (e.g.
it may decode using the <em>replace</em> error handler in Python). If the output stream
is a terminal, the build backend is responsible for presenting its output
accurately, as for any program running in a terminal.</p>
<p>If a hook raises an exception, or causes the process to terminate,
then this indicates an error.</p>
</section>
<section id="build-environment">
<h3><a class="toc-backref" href="#build-environment" role="doc-backlink">Build environment</a></h3>
<p>One of the responsibilities of a build frontend is to set up the
Python environment in which the build backend will run.</p>
<p>We do not require that any particular “virtual environment” mechanism
be used; a build frontend might use virtualenv, or venv, or no special
mechanism at all. But whatever mechanism is used MUST meet the
following criteria:</p>
<ul>
<li>All requirements specified by the project’s build-requirements must
be available for import from Python. In particular:<ul class="simple">
<li>The <code class="docutils literal notranslate"><span class="pre">get_requires_for_build_wheel</span></code> and <code class="docutils literal notranslate"><span class="pre">get_requires_for_build_sdist</span></code> hooks are
executed in an environment which contains the bootstrap requirements
specified in the <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> file.</li>
<li>The <code class="docutils literal notranslate"><span class="pre">prepare_metadata_for_build_wheel</span></code> and <code class="docutils literal notranslate"><span class="pre">build_wheel</span></code> hooks are
executed in an environment which contains the
bootstrap requirements from <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> and those specified by the
<code class="docutils literal notranslate"><span class="pre">get_requires_for_build_wheel</span></code> hook.</li>
<li>The <code class="docutils literal notranslate"><span class="pre">build_sdist</span></code> hook is executed in an environment which contains the
bootstrap requirements from <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> and those specified by the
<code class="docutils literal notranslate"><span class="pre">get_requires_for_build_sdist</span></code> hook.</li>
</ul>
</li>
<li>This must remain true even for new Python subprocesses spawned by
the build environment, e.g. code like:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">subprocess</span>
<span class="n">subprocess</span><span class="o">.</span><span class="n">check_call</span><span class="p">([</span><span class="n">sys</span><span class="o">.</span><span class="n">executable</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>
</pre></div>
</div>
<p>must spawn a Python process which has access to all the project’s
build-requirements. This is necessary e.g. for build backends that
want to run legacy <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> scripts in a subprocess.</p>
</li>
<li>All command-line scripts provided by the build-required packages
must be present in the build environment’s PATH. For example, if a
project declares a build-requirement on <a class="reference external" href="https://flit.readthedocs.org/en/latest/">flit</a>, then the following must
work as a mechanism for running the flit command-line tool:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="n">subprocess</span><span class="o">.</span><span class="n">check_call</span><span class="p">([</span><span class="n">shutil</span><span class="o">.</span><span class="n">which</span><span class="p">(</span><span class="s2">&quot;flit&quot;</span><span class="p">),</span> <span class="o">...</span><span class="p">])</span>
</pre></div>
</div>
</li>
</ul>
<p>A build backend MUST be prepared to function in any environment which
meets the above criteria. In particular, it MUST NOT assume that it
has access to any packages except those that are present in the
stdlib, or that are explicitly declared as build-requirements.</p>
<p>Frontends should call each hook in a fresh subprocess, so that backends are
free to change process global state (such as environment variables or the
working directory). A Python library will be provided which frontends can use
to easily call hooks this way.</p>
<section id="recommendations-for-build-frontends-non-normative">
<h4><a class="toc-backref" href="#recommendations-for-build-frontends-non-normative" role="doc-backlink">Recommendations for build frontends (non-normative)</a></h4>
<p>A build frontend MAY use any mechanism for setting up a build
environment that meets the above criteria. For example, simply
installing all build-requirements into the global environment would be
sufficient to build any compliant package – but this would be
sub-optimal for a number of reasons. This section contains
non-normative advice to frontend implementors.</p>
<p>A build frontend SHOULD, by default, create an isolated environment
for each build, containing only the standard library and any
explicitly requested build-dependencies. This has two benefits:</p>
<ul class="simple">
<li>It allows for a single installation run to build multiple packages
that have contradictory build-requirements. E.g. if package1
build-requires pbr==1.8.1, and package2 build-requires pbr==1.7.2,
then these cannot both be installed simultaneously into the global
environment – which is a problem when the user requests <code class="docutils literal notranslate"><span class="pre">pip</span>
<span class="pre">install</span> <span class="pre">package1</span> <span class="pre">package2</span></code>. Or if the user already has pbr==1.8.1
installed in their global environment, and a package build-requires
pbr==1.7.2, then downgrading the user’s version would be rather
rude.</li>
<li>It acts as a kind of public health measure to maximize the number of
packages that actually do declare accurate build-dependencies. We
can write all the strongly worded admonitions to package authors we
want, but if build frontends don’t enforce isolation by default,
then we’ll inevitably end up with lots of packages on PyPI that
build fine on the original author’s machine and nowhere else, which
is a headache that no-one needs.</li>
</ul>
<p>However, there will also be situations where build-requirements are
problematic in various ways. For example, a package author might
accidentally leave off some crucial requirement despite our best
efforts; or, a package might declare a build-requirement on <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">&gt;=</span>
<span class="pre">1.0</span></code> which worked great when 1.0 was the latest version, but now 1.1
is out and it has a showstopper bug; or, the user might decide to
build a package against numpy==1.7 – overriding the package’s
preferred numpy==1.8 – to guarantee that the resulting build will be
compatible at the C ABI level with an older version of numpy (even if
this means the resulting build is unsupported upstream). Therefore,
build frontends SHOULD provide some mechanism for users to override
the above defaults. For example, a build frontend could have a
<code class="docutils literal notranslate"><span class="pre">--build-with-system-site-packages</span></code> option that causes the
<code class="docutils literal notranslate"><span class="pre">--system-site-packages</span></code> option to be passed to
virtualenv-or-equivalent when creating build environments, or a
<code class="docutils literal notranslate"><span class="pre">--build-requirements-override=my-requirements.txt</span></code> option that
overrides the project’s normal build-requirements.</p>
<p>The general principle here is that we want to enforce hygiene on
package <em>authors</em>, while still allowing <em>end-users</em> to open up the
hood and apply duct tape when necessary.</p>
</section>
</section>
<section id="in-tree-build-backends">
<h3><a class="toc-backref" href="#in-tree-build-backends" role="doc-backlink">In-tree build backends</a></h3>
<p>In certain circumstances, projects may wish to include the source code for the
build backend directly in the source tree, rather than referencing the backend
via the <code class="docutils literal notranslate"><span class="pre">requires</span></code> key. Two specific situations where this would be expected
are:</p>
<ul class="simple">
<li>Backends themselves, which want to use their own features for building
themselves (“self-hosting backends”)</li>
<li>Project-specific backends, typically consisting of a custom wrapper around a
standard backend, where the wrapper is too project-specific to be worth
distributing independently (“in-tree backends”)</li>
</ul>
<p>Projects can specify that their backend code is hosted in-tree by including the
<code class="docutils literal notranslate"><span class="pre">backend-path</span></code> key in <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>. This key contains a list of
directories, which the frontend will add to the start of <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> when
loading the backend, and running the backend hooks.</p>
<p>There are two restrictions on the content of the <code class="docutils literal notranslate"><span class="pre">backend-path</span></code> key:</p>
<ul class="simple">
<li>Directories in <code class="docutils literal notranslate"><span class="pre">backend-path</span></code> are interpreted as relative to the project
root, and MUST refer to a location within the source tree (after relative
paths and symbolic links have been resolved).</li>
<li>The backend code MUST be loaded from one of the directories specified in
<code class="docutils literal notranslate"><span class="pre">backend-path</span></code> (i.e., it is not permitted to specify <code class="docutils literal notranslate"><span class="pre">backend-path</span></code> and
<em>not</em> have in-tree backend code).</li>
</ul>
<p>The first restriction is to ensure that source trees remain self-contained,
and cannot refer to locations outside of the source tree. Frontends SHOULD
check this condition (typically by resolving the location to an absolute path
and resolving symbolic links, and then checking it against the project root),
and fail with an error message if it is violated.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">backend-path</span></code> feature is intended to support the implementation of
in-tree backends, and not to allow configuration of existing backends. The
second restriction above is specifically to ensure that this is how the feature
is used. Front ends MAY enforce this check, but are not required to. Doing so
would typically involve checking the backend’s <code class="docutils literal notranslate"><span class="pre">__file__</span></code> attribute against
the locations in <code class="docutils literal notranslate"><span class="pre">backend-path</span></code>.</p>
</section>
</section>
<section id="source-distributions">
<h2><a class="toc-backref" href="#source-distributions" role="doc-backlink">Source distributions</a></h2>
<p>We continue with the legacy sdist format, adding some new restrictions.
This format is mostly
undefined, but basically comes down to: a file named
<code class="docutils literal notranslate"><span class="pre">{NAME}-{VERSION}.{EXT}</span></code>, which unpacks into a buildable source tree
called <code class="docutils literal notranslate"><span class="pre">{NAME}-{VERSION}/</span></code>. Traditionally these have always
contained <code class="docutils literal notranslate"><span class="pre">setup.py</span></code>-style source trees; we now allow them to also
contain <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>-style source trees.</p>
<p>Integration frontends require that an sdist named
<code class="docutils literal notranslate"><span class="pre">{NAME}-{VERSION}.{EXT}</span></code> will generate a wheel named
<code class="docutils literal notranslate"><span class="pre">{NAME}-{VERSION}-{COMPAT-INFO}.whl</span></code>.</p>
<p>The new restrictions for sdists built by <a class="pep reference internal" href="../pep-0517" title="PEP 517 – A build-system independent format for source trees">PEP 517</a> backends are:</p>
<ul class="simple">
<li>They will be gzipped tar archives, with the <code class="docutils literal notranslate"><span class="pre">.tar.gz</span></code> extension. Zip
archives, or other compression formats for tarballs, are not allowed at
present.</li>
<li>Tar archives must be created in the modern POSIX.1-2001 pax tar format, which
uses UTF-8 for file names.</li>
<li>The source tree contained in an sdist is expected to include the
<code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> file.</li>
</ul>
</section>
<section id="evolutionary-notes">
<h2><a class="toc-backref" href="#evolutionary-notes" role="doc-backlink">Evolutionary notes</a></h2>
<p>A goal here is to make it as simple as possible to convert old-style
sdists to new-style sdists. (E.g., this is one motivation for
supporting dynamic build requirements.) The ideal would be that there
would be a single static <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> that could be dropped into any
“version 0” VCS checkout to convert it to the new shiny. This is
probably not 100% possible, but we can get close, and it’s important
to keep track of how close we are… hence this section.</p>
<p>A rough plan would be: Create a build system package
(<code class="docutils literal notranslate"><span class="pre">setuptools_pypackage</span></code> or whatever) that knows how to speak
whatever hook language we come up with, and convert them into calls to
<code class="docutils literal notranslate"><span class="pre">setup.py</span></code>. This will probably require some sort of hooking or
monkeypatching to setuptools to provide a way to extract the
<code class="docutils literal notranslate"><span class="pre">setup_requires=</span></code> argument when needed, and to provide a new version
of the sdist command that generates the new-style format. This all
seems doable and sufficient for a large proportion of packages (though
obviously we’ll want to prototype such a system before we finalize
anything here). (Alternatively, these changes could be made to
setuptools itself rather than going into a separate package.)</p>
<p>But there remain two obstacles that mean we probably won’t be able to
automatically upgrade packages to the new format:</p>
<ol class="arabic simple">
<li>There currently exist packages which insist on particular packages
being available in their environment before setup.py is
executed. This means that if we decide to execute build scripts in
an isolated virtualenv-like environment, then projects will need to
check whether they do this, and if so then when upgrading to the
new system they will have to start explicitly declaring these
dependencies (either via <code class="docutils literal notranslate"><span class="pre">setup_requires=</span></code> or via static
declaration in <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code>).</li>
<li>There currently exist packages which do not declare consistent
metadata (e.g. <code class="docutils literal notranslate"><span class="pre">egg_info</span></code> and <code class="docutils literal notranslate"><span class="pre">bdist_wheel</span></code> might get different
<code class="docutils literal notranslate"><span class="pre">install_requires=</span></code>). When upgrading to the new system, projects
will have to evaluate whether this applies to them, and if so they
will need to stop doing that.</li>
</ol>
</section>
<section id="rejected-options">
<h2><a class="toc-backref" href="#rejected-options" role="doc-backlink">Rejected options</a></h2>
<ul class="simple">
<li>We discussed making the wheel and sdist hooks build unpacked directories
containing the same contents as their respective archives. In some cases this
could avoid the need to pack and unpack an archive, but this seems like
premature optimisation. It’s advantageous for tools to work with archives
as the canonical interchange formats (especially for wheels, where the archive
format is already standardised). Close control of archive creation is
important for reproducible builds. And it’s not clear that tasks requiring an
unpacked distribution will be more common than those requiring an archive.</li>
<li>We considered an extra hook to copy files to a build directory before invoking
<code class="docutils literal notranslate"><span class="pre">build_wheel</span></code>. Looking at existing build systems, we found that passing
a build directory into <code class="docutils literal notranslate"><span class="pre">build_wheel</span></code> made more sense for many tools than
pre-emptively copying files into a build directory.</li>
<li>The idea of passing <code class="docutils literal notranslate"><span class="pre">build_wheel</span></code> a build directory was then also deemed an
unnecessary complication. Build tools can use a temporary directory or a cache
directory to store intermediate files while building. If there is a need, a
frontend-controlled cache directory could be added in the future.</li>
<li>For <code class="docutils literal notranslate"><span class="pre">build_sdist</span></code> to signal a failure for an expected reason, various
options were debated at great length, including raising
<code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code> and returning either <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code>.
Please do not attempt to reopen this discussion without an <em>extremely</em> good
reason, because we are quite tired of it.</li>
<li>Allowing the backend to be imported from files in the source tree would be
more consistent with the way Python imports often work. However, not allowing
this prevents confusing errors from clashing module names. The initial
version of this PEP did not provide a means to allow backends to be
imported from files within the source tree, but the <code class="docutils literal notranslate"><span class="pre">backend-path</span></code> key
was added in the next revision to allow projects to opt into this behaviour
if needed.</li>
</ul>
</section>
<section id="summary-of-changes-to-pep-517">
<h2><a class="toc-backref" href="#summary-of-changes-to-pep-517" role="doc-backlink">Summary of changes to PEP 517</a></h2>
<p>The following changes were made to this PEP after the initial reference
implementation was released in pip 19.0.</p>
<ul class="simple">
<li>Cycles in build requirements were explicitly prohibited.</li>
<li>Support for in-tree backends and self-hosting of backends was added by
the introduction of the <code class="docutils literal notranslate"><span class="pre">backend-path</span></code> key in the <code class="docutils literal notranslate"><span class="pre">[build-system]</span></code>
table.</li>
<li>Clarified that the <code class="docutils literal notranslate"><span class="pre">setuptools.build_meta:__legacy__</span></code> <a class="pep reference internal" href="../pep-0517" title="PEP 517 – A build-system independent format for source trees">PEP 517</a> backend is
an acceptable alternative to directly invoking <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> for source trees
that don’t specify <code class="docutils literal notranslate"><span class="pre">build-backend</span></code> explicitly.</li>
</ul>
</section>
<section id="appendix-a-comparison-to-pep-516">
<h2><a class="toc-backref" href="#appendix-a-comparison-to-pep-516" role="doc-backlink">Appendix A: Comparison to PEP 516</a></h2>
<p><a class="pep reference internal" href="../pep-0516" title="PEP 516 – Build system abstraction for pip/conda etc">PEP 516</a> is a competing proposal to specify a build system interface, which
has now been rejected in favour of this PEP. The primary difference is
that our build backend is defined via a Python hook-based interface
rather than a command-line based interface.</p>
<p>This appendix documents the arguments advanced for this PEP over <a class="pep reference internal" href="../pep-0516" title="PEP 516 – Build system abstraction for pip/conda etc">PEP 516</a>.</p>
<p>We do <em>not</em> expect that specifying Python hooks rather than command line
interfaces will, by itself, reduce the
complexity of calling into the backend, because build frontends will
in any case want to run hooks inside a child – this is important to
isolate the build frontend itself from the backend code and to better
control the build backends execution environment. So under both
proposals, there will need to be some code in <code class="docutils literal notranslate"><span class="pre">pip</span></code> to spawn a
subprocess and talk to some kind of command-line/IPC interface, and
there will need to be some code in the subprocess that knows how to
parse these command line arguments and call the actual build backend
implementation. So this diagram applies to all proposals equally:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+-----------+</span>          <span class="o">+---------------+</span>           <span class="o">+----------------+</span>
<span class="o">|</span> <span class="n">frontend</span>  <span class="o">|</span> <span class="o">-</span><span class="n">spawn</span><span class="o">-&gt;</span> <span class="o">|</span> <span class="n">child</span> <span class="n">cmdline</span> <span class="o">|</span> <span class="o">-</span><span class="n">Python</span><span class="o">-&gt;</span> <span class="o">|</span>    <span class="n">backend</span>     <span class="o">|</span>
<span class="o">|</span>   <span class="p">(</span><span class="n">pip</span><span class="p">)</span>   <span class="o">|</span>          <span class="o">|</span>   <span class="n">interface</span>   <span class="o">|</span>           <span class="o">|</span> <span class="n">implementation</span> <span class="o">|</span>
<span class="o">+-----------+</span>          <span class="o">+---------------+</span>           <span class="o">+----------------+</span>
</pre></div>
</div>
<p>The key difference between the two approaches is how these interface
boundaries map onto project structure:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">.-=</span> <span class="n">This</span> <span class="n">PEP</span> <span class="o">=-.</span>

<span class="o">+-----------+</span>          <span class="o">+---------------+</span>    <span class="o">|</span>      <span class="o">+----------------+</span>
<span class="o">|</span> <span class="n">frontend</span>  <span class="o">|</span> <span class="o">-</span><span class="n">spawn</span><span class="o">-&gt;</span> <span class="o">|</span> <span class="n">child</span> <span class="n">cmdline</span> <span class="o">|</span> <span class="o">-</span><span class="n">Python</span><span class="o">-&gt;</span> <span class="o">|</span>    <span class="n">backend</span>     <span class="o">|</span>
<span class="o">|</span>   <span class="p">(</span><span class="n">pip</span><span class="p">)</span>   <span class="o">|</span>          <span class="o">|</span>   <span class="n">interface</span>   <span class="o">|</span>    <span class="o">|</span>      <span class="o">|</span> <span class="n">implementation</span> <span class="o">|</span>
<span class="o">+-----------+</span>          <span class="o">+---------------+</span>    <span class="o">|</span>      <span class="o">+----------------+</span>
                                            <span class="o">|</span>
<span class="o">|</span><span class="n">______________________________________</span><span class="o">|</span>    <span class="o">|</span>
   <span class="n">Owned</span> <span class="n">by</span> <span class="n">pip</span><span class="p">,</span> <span class="n">updated</span> <span class="ow">in</span> <span class="n">lockstep</span>        <span class="o">|</span>
                                            <span class="o">|</span>
                                            <span class="o">|</span>
                                 <span class="n">PEP</span><span class="o">-</span><span class="n">defined</span> <span class="n">interface</span> <span class="n">boundary</span>
                               <span class="n">Changes</span> <span class="n">here</span> <span class="n">require</span> <span class="n">distutils</span><span class="o">-</span><span class="n">sig</span>


<span class="o">.-=</span> <span class="n">Alternative</span> <span class="o">=-.</span>

<span class="o">+-----------+</span>    <span class="o">|</span>     <span class="o">+---------------+</span>           <span class="o">+----------------+</span>
<span class="o">|</span> <span class="n">frontend</span>  <span class="o">|</span> <span class="o">-</span><span class="n">spawn</span><span class="o">-&gt;</span> <span class="o">|</span> <span class="n">child</span> <span class="n">cmdline</span> <span class="o">|</span> <span class="o">-</span><span class="n">Python</span><span class="o">-&gt;</span> <span class="o">|</span>    <span class="n">backend</span>     <span class="o">|</span>
<span class="o">|</span>   <span class="p">(</span><span class="n">pip</span><span class="p">)</span>   <span class="o">|</span>    <span class="o">|</span>     <span class="o">|</span>   <span class="n">interface</span>   <span class="o">|</span>           <span class="o">|</span> <span class="n">implementation</span> <span class="o">|</span>
<span class="o">+-----------+</span>    <span class="o">|</span>     <span class="o">+---------------+</span>           <span class="o">+----------------+</span>
                 <span class="o">|</span>
                 <span class="o">|</span>     <span class="o">|</span><span class="n">____________________________________________</span><span class="o">|</span>
                 <span class="o">|</span>      <span class="n">Owned</span> <span class="n">by</span> <span class="n">build</span> <span class="n">backend</span><span class="p">,</span> <span class="n">updated</span> <span class="ow">in</span> <span class="n">lockstep</span>
                 <span class="o">|</span>
    <span class="n">PEP</span><span class="o">-</span><span class="n">defined</span> <span class="n">interface</span> <span class="n">boundary</span>
  <span class="n">Changes</span> <span class="n">here</span> <span class="n">require</span> <span class="n">distutils</span><span class="o">-</span><span class="n">sig</span>
</pre></div>
</div>
<p>By moving the PEP-defined interface boundary into Python code, we gain
three key advantages.</p>
<p><strong>First</strong>, because there will likely be only a small number of build
frontends (<code class="docutils literal notranslate"><span class="pre">pip</span></code>, and… maybe a few others?), while there will
likely be a long tail of custom build backends (since these are chosen
separately by each package to match their particular build
requirements), the actual diagrams probably look more like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">.-=</span> <span class="n">This</span> <span class="n">PEP</span> <span class="o">=-.</span>

<span class="o">+-----------+</span>          <span class="o">+---------------+</span>           <span class="o">+----------------+</span>
<span class="o">|</span> <span class="n">frontend</span>  <span class="o">|</span> <span class="o">-</span><span class="n">spawn</span><span class="o">-&gt;</span> <span class="o">|</span> <span class="n">child</span> <span class="n">cmdline</span> <span class="o">|</span> <span class="o">-</span><span class="n">Python</span><span class="o">+&gt;</span> <span class="o">|</span>    <span class="n">backend</span>     <span class="o">|</span>
<span class="o">|</span>   <span class="p">(</span><span class="n">pip</span><span class="p">)</span>   <span class="o">|</span>          <span class="o">|</span>   <span class="n">interface</span>   <span class="o">|</span>        <span class="o">|</span>  <span class="o">|</span> <span class="n">implementation</span> <span class="o">|</span>
<span class="o">+-----------+</span>          <span class="o">+---------------+</span>        <span class="o">|</span>  <span class="o">+----------------+</span>
                                                <span class="o">|</span>
                                                <span class="o">|</span>  <span class="o">+----------------+</span>
                                                <span class="o">+&gt;</span> <span class="o">|</span>    <span class="n">backend</span>     <span class="o">|</span>
                                                <span class="o">|</span>  <span class="o">|</span> <span class="n">implementation</span> <span class="o">|</span>
                                                <span class="o">|</span>  <span class="o">+----------------+</span>
                                                <span class="p">:</span>
                                                <span class="p">:</span>

<span class="o">.-=</span> <span class="n">Alternative</span> <span class="o">=-.</span>

<span class="o">+-----------+</span>          <span class="o">+---------------+</span>           <span class="o">+----------------+</span>
<span class="o">|</span> <span class="n">frontend</span>  <span class="o">|</span> <span class="o">-</span><span class="n">spawn</span><span class="o">+&gt;</span> <span class="o">|</span> <span class="n">child</span> <span class="n">cmdline</span> <span class="o">|</span> <span class="o">-</span><span class="n">Python</span><span class="o">-&gt;</span> <span class="o">|</span>    <span class="n">backend</span>     <span class="o">|</span>
<span class="o">|</span>   <span class="p">(</span><span class="n">pip</span><span class="p">)</span>   <span class="o">|</span>       <span class="o">|</span>  <span class="o">|</span>   <span class="n">interface</span>   <span class="o">|</span>           <span class="o">|</span> <span class="n">implementation</span> <span class="o">|</span>
<span class="o">+-----------+</span>       <span class="o">|</span>  <span class="o">+---------------+</span>           <span class="o">+----------------+</span>
                    <span class="o">|</span>
                    <span class="o">|</span>  <span class="o">+---------------+</span>           <span class="o">+----------------+</span>
                    <span class="o">+&gt;</span> <span class="o">|</span> <span class="n">child</span> <span class="n">cmdline</span> <span class="o">|</span> <span class="o">-</span><span class="n">Python</span><span class="o">-&gt;</span> <span class="o">|</span>    <span class="n">backend</span>     <span class="o">|</span>
                    <span class="o">|</span>  <span class="o">|</span>   <span class="n">interface</span>   <span class="o">|</span>           <span class="o">|</span> <span class="n">implementation</span> <span class="o">|</span>
                    <span class="o">|</span>  <span class="o">+---------------+</span>           <span class="o">+----------------+</span>
                    <span class="p">:</span>
                    <span class="p">:</span>
</pre></div>
</div>
<p>That is, this PEP leads to less total code in the overall
ecosystem. And in particular, it reduces the barrier to entry of
making a new build system. For example, this is a complete, working
build backend:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># mypackage_custom_build_backend.py</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">tarfile</span>

<span class="n">SDIST_NAME</span> <span class="o">=</span> <span class="s2">&quot;mypackage-0.1&quot;</span>
<span class="n">SDIST_FILENAME</span> <span class="o">=</span> <span class="n">SDIST_NAME</span> <span class="o">+</span> <span class="s2">&quot;.tar.gz&quot;</span>
<span class="n">WHEEL_FILENAME</span> <span class="o">=</span> <span class="s2">&quot;mypackage-0.1-py2.py3-none-any.whl&quot;</span>

<span class="c1">#################</span>
<span class="c1"># sdist creation</span>
<span class="c1">#################</span>

<span class="k">def</span> <span class="nf">_exclude_hidden_and_special_files</span><span class="p">(</span><span class="n">archive_entry</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Tarfile filter to exclude hidden and special files from the archive&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">archive_entry</span><span class="o">.</span><span class="n">isfile</span><span class="p">()</span> <span class="ow">or</span> <span class="n">archive_entry</span><span class="o">.</span><span class="n">isdir</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">archive_entry</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">archive_entry</span>

<span class="k">def</span> <span class="nf">_make_sdist</span><span class="p">(</span><span class="n">sdist_dir</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make an sdist and return both the Python object and its filename&quot;&quot;&quot;</span>
    <span class="n">sdist_path</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">sdist_dir</span><span class="p">)</span> <span class="o">/</span> <span class="n">SDIST_FILENAME</span>
    <span class="n">sdist</span> <span class="o">=</span> <span class="n">tarfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">sdist_path</span><span class="p">,</span> <span class="s2">&quot;w:gz&quot;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">tarfile</span><span class="o">.</span><span class="n">PAX_FORMAT</span><span class="p">)</span>
    <span class="c1"># Tar up the whole directory, minus hidden and special files</span>
    <span class="n">sdist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">arcname</span><span class="o">=</span><span class="n">SDIST_NAME</span><span class="p">,</span>
              <span class="nb">filter</span><span class="o">=</span><span class="n">_exclude_hidden_and_special_files</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sdist</span><span class="p">,</span> <span class="n">SDIST_FILENAME</span>

<span class="k">def</span> <span class="nf">build_sdist</span><span class="p">(</span><span class="n">sdist_dir</span><span class="p">,</span> <span class="n">config_settings</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;PEP 517 sdist creation hook&quot;&quot;&quot;</span>
    <span class="n">sdist</span><span class="p">,</span> <span class="n">sdist_filename</span> <span class="o">=</span> <span class="n">_make_sdist</span><span class="p">(</span><span class="n">sdist_dir</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sdist_filename</span>

<span class="c1">#################</span>
<span class="c1"># wheel creation</span>
<span class="c1">#################</span>

<span class="k">def</span> <span class="nf">get_requires_for_build_wheel</span><span class="p">(</span><span class="n">config_settings</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;PEP 517 wheel building dependency definition hook&quot;&quot;&quot;</span>
    <span class="c1"># As a simple static requirement, this could also just be</span>
    <span class="c1"># listed in the project&#39;s build system dependencies instead</span>
    <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;wheel&quot;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">build_wheel</span><span class="p">(</span><span class="n">wheel_directory</span><span class="p">,</span>
                <span class="n">metadata_directory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">config_settings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;PEP 517 wheel creation hook&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">wheel.archive</span> <span class="kn">import</span> <span class="n">archive_wheelfile</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">wheel_directory</span><span class="p">,</span> <span class="n">WHEEL_FILENAME</span><span class="p">)</span>
    <span class="n">archive_wheelfile</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;src/&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">WHEEL_FILENAME</span>
</pre></div>
</div>
<p>Of course, this is a <em>terrible</em> build backend: it requires the user to
have manually set up the wheel metadata in
<code class="docutils literal notranslate"><span class="pre">src/mypackage-0.1.dist-info/</span></code>; when the version number changes it
must be manually updated in multiple places… but it works, and more features
could be added incrementally. Much experience suggests that large successful
projects often originate as quick hacks (e.g., Linux – “just a hobby,
won’t be big and professional”; <a class="reference external" href="https://en.wikipedia.org/wiki/IPython#Grants_and_awards">IPython/Jupyter</a> – <a class="reference external" href="http://blog.fperez.org/2012/01/ipython-notebook-historical.html">a grad
student’s $PYTHONSTARTUP file</a>),
so if our goal is to encourage the growth of a vibrant ecosystem of
good build tools, it’s important to minimize the barrier to entry.</p>
<p><strong>Second</strong>, because Python provides a simpler yet richer structure for
describing interfaces, we remove unnecessary complexity from the
specification – and specifications are the worst place for
complexity, because changing specifications requires painful
consensus-building across many stakeholders. In the command-line
interface approach, we have to come up with ad hoc ways to map
multiple different kinds of inputs into a single linear command line
(e.g. how do we avoid collisions between user-specified configuration
arguments and PEP-defined arguments? how do we specify optional
arguments? when working with a Python interface these questions have
simple, obvious answers). When spawning and managing subprocesses,
there are many fiddly details that must be gotten right, subtle
cross-platform differences, and some of the most obvious approaches –
e.g., using stdout to return data for the <code class="docutils literal notranslate"><span class="pre">build_requires</span></code> operation
– can create unexpected pitfalls (e.g., what happens when computing
the build requirements requires spawning some child processes, and
these children occasionally print an error message to stdout?
obviously a careful build backend author can avoid this problem, but
the most obvious way of defining a Python interface removes this
possibility entirely, because the hook return value is clearly
demarcated).</p>
<p>In general, the need to isolate build backends into their own process
means that we can’t remove IPC complexity entirely – but by placing
both sides of the IPC channel under the control of a single project,
we make it much cheaper to fix bugs in the IPC interface than if
fixing bugs requires coordinated agreement and coordinated changes
across the ecosystem.</p>
<p><strong>Third</strong>, and most crucially, the Python hook approach gives us much
more powerful options for evolving this specification in the future.</p>
<p>For concreteness, imagine that next year we add a new
<code class="docutils literal notranslate"><span class="pre">build_sdist_from_vcs</span></code> hook, which provides an alternative to the current
<code class="docutils literal notranslate"><span class="pre">build_sdist</span></code> hook where the frontend is responsible for passing
version control tracking metadata to backends (including indicating when all
on disk files are tracked), rather than individual backends having to query that
information themselves. In order to manage the transition, we’d want it to be
possible for build frontends to transparently use <code class="docutils literal notranslate"><span class="pre">build_sdist_from_vcs</span></code> when
available and fall back onto <code class="docutils literal notranslate"><span class="pre">build_sdist</span></code> otherwise; and we’d want it to be
possible for build backends to define both methods, for compatibility
with both old and new build frontends.</p>
<p>Furthermore, our mechanism should also fulfill two more goals: (a) If
new versions of e.g. <code class="docutils literal notranslate"><span class="pre">pip</span></code> and <code class="docutils literal notranslate"><span class="pre">flit</span></code> are both updated to support
the new interface, then this should be sufficient for it to be used;
in particular, it should <em>not</em> be necessary for every project that
<em>uses</em> <code class="docutils literal notranslate"><span class="pre">flit</span></code> to update its individual <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> file. (b)
We do not want to have to spawn extra processes just to perform this
negotiation, because process spawns can easily become a bottleneck when
deploying large multi-package stacks on some platforms (Windows).</p>
<p>In the interface described here, all of these goals are easy to
achieve. Because <code class="docutils literal notranslate"><span class="pre">pip</span></code> controls the code that runs inside the child
process, it can easily write it to do something like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">command</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">parse_command_line_args</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="k">if</span> <span class="n">command</span> <span class="o">==</span> <span class="s2">&quot;build_sdist&quot;</span><span class="p">:</span>
   <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">backend</span><span class="p">,</span> <span class="s2">&quot;build_sdist_from_vcs&quot;</span><span class="p">):</span>
       <span class="n">backend</span><span class="o">.</span><span class="n">build_sdist_from_vcs</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
   <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">backend</span><span class="p">,</span> <span class="s2">&quot;build_sdist&quot;</span><span class="p">):</span>
       <span class="n">backend</span><span class="o">.</span><span class="n">build_sdist</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
   <span class="k">else</span><span class="p">:</span>
       <span class="c1"># error handling</span>
</pre></div>
</div>
<p>In the alternative where the public interface boundary is placed at
the subprocess call, this is not possible – either we need to spawn
an extra process just to query what interfaces are supported (as was
included in an earlier draft of <a class="pep reference internal" href="../pep-0516" title="PEP 516 – Build system abstraction for pip/conda etc">PEP 516</a>, an alternative to this), or
else we give up on autonegotiation entirely (as in the current version
of that PEP), meaning that any changes in the interface will require
N individual packages to update their <code class="docutils literal notranslate"><span class="pre">pyproject.toml</span></code> files before
any change can go live, and that any changes will necessarily be
restricted to new releases.</p>
<p>One specific consequence of this is that in this PEP, we’re able to
make the <code class="docutils literal notranslate"><span class="pre">prepare_metadata_for_build_wheel</span></code> command optional. In our design,
this can be readily handled by build frontends, which can put code in
their subprocess runner like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dump_wheel_metadata</span><span class="p">(</span><span class="n">backend</span><span class="p">,</span> <span class="n">working_dir</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dumps wheel metadata to working directory.</span>

<span class="sd">       Returns absolute path to resulting metadata directory</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">backend</span><span class="p">,</span> <span class="s2">&quot;prepare_metadata_for_build_wheel&quot;</span><span class="p">):</span>
        <span class="n">subdir</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">prepare_metadata_for_build_wheel</span><span class="p">(</span><span class="n">working_dir</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">wheel_fname</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">build_wheel</span><span class="p">(</span><span class="n">working_dir</span><span class="p">)</span>
        <span class="n">already_built</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">working_dir</span><span class="p">,</span> <span class="s2">&quot;ALREADY_BUILT_WHEEL&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">already_built</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">wheel_fname</span><span class="p">)</span>
        <span class="n">subdir</span> <span class="o">=</span> <span class="n">unzip_metadata</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">working_dir</span><span class="p">,</span> <span class="n">wheel_fname</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">working_dir</span><span class="p">,</span> <span class="n">subdir</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">ensure_wheel_is_built</span><span class="p">(</span><span class="n">backend</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">,</span> <span class="n">working_dir</span><span class="p">,</span> <span class="n">metadata_dir</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ensures built wheel is available in output directory</span>

<span class="sd">       Returns absolute path to resulting wheel file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">already_built</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">working_dir</span><span class="p">,</span> <span class="s2">&quot;ALREADY_BUILT_WHEEL&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">already_built</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">already_built</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">wheel_fname</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">working_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">working_dir</span><span class="p">,</span> <span class="n">wheel_fname</span><span class="p">)</span>
        <span class="n">final_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">wheel_fname</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">working_path</span><span class="p">,</span> <span class="n">final_path</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">already_built</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">wheel_fname</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">build_wheel</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">metadata_dir</span><span class="o">=</span><span class="n">metadata_dir</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">wheel_fname</span><span class="p">)</span>
</pre></div>
</div>
<p>and thus expose a totally uniform interface to the rest of the frontend,
with no extra subprocess calls, no duplicated builds, etc. But
obviously this is the kind of code that you only want to write as part
of a private, within-project interface (e.g. the given example requires that
the working directory be shared between the two calls, but not with any
other wheel builds, and that the return value from the metadata helper function
will be passed back in to the wheel building one).</p>
<p>(And, of course, making the <code class="docutils literal notranslate"><span class="pre">metadata</span></code> command optional is one piece
of lowering the barrier to entry for developing new backends, as discussed
above.)</p>
<section id="other-differences">
<h3><a class="toc-backref" href="#other-differences" role="doc-backlink">Other differences</a></h3>
<p>Besides the key command line versus Python hook difference described
above, there are a few other differences in this proposal:</p>
<ul class="simple">
<li>Metadata command is optional (as described above).</li>
<li>We return metadata as a directory, rather than a single METADATA
file. This aligns better with the way that in practice wheel metadata
is distributed across multiple files (e.g. entry points), and gives us
more options in the future. (For example, instead of following the PEP
426 proposal of switching the format of METADATA to JSON, we might
decide to keep the existing METADATA the way it is for backcompat,
while adding new extensions as JSON “sidecar” files inside the same
directory. Or maybe not; the point is it keeps our options more open.)</li>
<li>We provide a mechanism for passing information between the metadata
step and the wheel building step. I guess everyone probably will
agree this is a good idea?</li>
<li>We provide more detailed recommendations about the build environment,
but these aren’t normative anyway.</li>
</ul>
</section>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document has been placed in the public domain.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/pep-0517.txt">https://github.com/python/peps/blob/main/pep-0517.txt</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/pep-0517.txt">2022-06-14 21:22:20 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">摘要</a></li>
<li><a class="reference internal" href="#terminology-and-goals">术语和目标</a></li>
<li><a class="reference internal" href="#source-trees">源码树</a><ul>
<li><a class="reference internal" href="#build-requirements">构建需求</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-backend-interface">构建后端接口</a><ul>
<li><a class="reference internal" href="#mandatory-hooks">强制性的钩子</a><ul>
<li><a class="reference internal" href="#build-wheel">build_wheel</a></li>
<li><a class="reference internal" href="#build-sdist">build_sdist</a></li>
</ul>
</li>
<li><a class="reference internal" href="#optional-hooks">Optional hooks</a><ul>
<li><a class="reference internal" href="#get-requires-for-build-wheel">get_requires_for_build_wheel</a></li>
<li><a class="reference internal" href="#prepare-metadata-for-build-wheel">prepare_metadata_for_build_wheel</a></li>
<li><a class="reference internal" href="#get-requires-for-build-sdist">get_requires_for_build_sdist</a></li>
</ul>
</li>
<li><a class="reference internal" href="#config-settings">Config settings</a></li>
<li><a class="reference internal" href="#build-environment">Build environment</a><ul>
<li><a class="reference internal" href="#recommendations-for-build-frontends-non-normative">Recommendations for build frontends (non-normative)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#in-tree-build-backends">In-tree build backends</a></li>
</ul>
</li>
<li><a class="reference internal" href="#source-distributions">Source distributions</a></li>
<li><a class="reference internal" href="#evolutionary-notes">Evolutionary notes</a></li>
<li><a class="reference internal" href="#rejected-options">Rejected options</a></li>
<li><a class="reference internal" href="#summary-of-changes-to-pep-517">Summary of changes to PEP 517</a></li>
<li><a class="reference internal" href="#appendix-a-comparison-to-pep-516">Appendix A: Comparison to PEP 516</a><ul>
<li><a class="reference internal" href="#other-differences">Other differences</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/pep-0517.txt">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
</body>
</html>