
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 420 – Implicit Namespace Packages | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0420/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <meta name="description" content="Python Enhancement Proposals (PEPs)">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 420</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 420 – Implicit Namespace Packages</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Eric V. Smith &lt;eric&#32;&#97;t&#32;trueblade.com&gt;</dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Accepted and implementation complete, or no longer active">Final</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">19-Apr-2012</dd>
<dt class="field-odd">Python-Version<span class="colon">:</span></dt>
<dd class="field-odd">3.3</dd>
<dt class="field-even">Post-History<span class="colon">:</span></dt>
<dd class="field-even"><p></p></dd>
<dt class="field-odd">Resolution<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://mail.python.org/pipermail/python-dev/2012-May/119651.html">Python-Dev message</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">摘要</a></li>
<li><a class="reference internal" href="#terminology">术语</a></li>
<li><a class="reference internal" href="#namespace-packages-today">今天的命名空间包</a></li>
<li><a class="reference internal" href="#rationale">理论依据</a></li>
<li><a class="reference internal" href="#specification">规格</a><ul>
<li><a class="reference internal" href="#dynamic-path-computation">动态路径的计算</a></li>
<li><a class="reference internal" href="#impact-on-import-finders-and-loaders">对 import 发现器与加载器的影响</a></li>
<li><a class="reference internal" href="#differences-between-namespace-packages-and-regular-packages">Differences between namespace packages and regular packages</a></li>
<li><a class="reference internal" href="#namespace-packages-in-the-standard-library">Namespace packages in the standard library</a></li>
<li><a class="reference internal" href="#migrating-from-legacy-namespace-packages">Migrating from legacy namespace packages</a></li>
</ul>
</li>
<li><a class="reference internal" href="#packaging-implications">Packaging Implications</a></li>
<li><a class="reference internal" href="#examples">示例</a><ul>
<li><a class="reference internal" href="#nested-namespace-packages">嵌套的命名空间包</a></li>
<li><a class="reference internal" href="#id2">动态路径的计算</a></li>
</ul>
</li>
<li><a class="reference internal" href="#discussion">讨论</a><ul>
<li><a class="reference internal" href="#find-module-versus-find-loader"><code class="docutils literal notranslate"><span class="pre">find_module</span></code> versus <code class="docutils literal notranslate"><span class="pre">find_loader</span></code></a></li>
<li><a class="reference internal" href="#id8">动态路径的计算</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-reprs">Module reprs</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">摘要</a></h2>
<p>Namespace packages are a mechanism for splitting a single Python package
across multiple directories on disk.  In current Python versions, an algorithm
to compute the packages <code class="docutils literal notranslate"><span class="pre">__path__</span></code> must be formulated.  With the enhancement
proposed here, the import machinery itself will construct the list of
directories that make up the package.  This PEP builds upon previous work,
documented in <a class="pep reference internal" href="../pep-0382" title="PEP 382 – Namespace Packages">PEP 382</a> and <a class="pep reference internal" href="../pep-0402" title="PEP 402 – Simplified Package Layout and Partitioning">PEP 402</a>.  Those PEPs have since been rejected in
favor of this one.  An implementation of this PEP is at <a class="footnote-reference brackets" href="#id11" id="id1">[1]</a>.</p>
</section>
<section id="terminology">
<h2><a class="toc-backref" href="#terminology" role="doc-backlink">术语</a></h2>
<p>在此 PEP 中：</p>
<ul class="simple">
<li>“package” 指的是由 Python 的导入语句定义的 Python 包。</li>
<li>“distribution” 指的是存储在 Python 包索引中，并由 distutils 或 setuptools 安装的可单独安装的 Python 模块集。</li>
<li>“vendor package” 指的是由操作系统的打包机制安装的文件组（例如，Debian 或 Redhat 软件包在 Linux 系统上的安装）。</li>
<li>“regular package” 指的是 Python 3.2 和更早版本中实现的包。</li>
<li>“portion” 指的是一个单一目录中的一组文件（可能存储在一个压缩文件中），这些文件对一个命名空间包有贡献。</li>
<li>“legacy portion” 指的是为了实现命名空间包而使用 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 操作的部分。</li>
</ul>
<p>这个 PEP 定义了一种新的包的类型，即 “namespace package”。</p>
</section>
<section id="namespace-packages-today">
<h2><a class="toc-backref" href="#namespace-packages-today" role="doc-backlink">今天的命名空间包</a></h2>
<p>Python 目前提供了 <code class="docutils literal notranslate"><span class="pre">pkgutil.extend_path</span></code> 来表示一个包为命名空间包。推荐的使用方法是把</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pkgutil</span> <span class="kn">import</span> <span class="n">extend_path</span>
<span class="n">__path__</span> <span class="o">=</span> <span class="n">extend_path</span><span class="p">(</span><span class="n">__path__</span><span class="p">,</span> <span class="vm">__name__</span><span class="p">)</span>
</pre></div>
</div>
<p>放在包的 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 中。每个发行版都需要在其 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 中提供相同的内容，这样 <code class="docutils literal notranslate"><span class="pre">extend_path</span></code> 的调用就与软件包的哪一部分先被导入无关。因此，软件包的 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 实际上不能定义任何名字，因为它依赖于 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 上的软件包片段的顺序来决定哪部分先被导入。作为一个特殊的功能，<code class="docutils literal notranslate"><span class="pre">extend_path</span></code> 读取名为 <code class="docutils literal notranslate"><span class="pre">&lt;packagename&gt;.pkg</span></code> 的文件，允许声明额外的部分。</p>
<p>setuptools 提供了一个类似的函数，名为 <code class="docutils literal notranslate"><span class="pre">pkg_resources.declare_namespace</span></code> ，其使用形式为</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pkg_resources</span>
<span class="n">pkg_resources</span><span class="o">.</span><span class="n">declare_namespace</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
</pre></div>
</div>
<p>在该部分的 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 中，不需要对 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 进行赋值，因为 <code class="docutils literal notranslate"><span class="pre">declare_namespace</span></code> 通过 <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code> 修改了软件包 <code class="docutils literal notranslate"><span class="pre">__path__</span></code>。作为一个特殊的功能，<code class="docutils literal notranslate"><span class="pre">declare_namespace</span></code> 也支持压缩文件，并在内部注册包的名称，以便将来 setuptools 对 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 的添加可以正确地添加到每个包的附加部分。</p>
<p>setuptools 允许在发行版的 <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> 中声明命名空间包，这样发行版的开发者就不需要自己把神奇的 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 修改到 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 中。</p>
<p>See <a class="pep reference internal" href="../pep-0402" title="PEP 402 – Simplified Package Layout and Partitioning">PEP 402</a>’s <a class="pep reference internal" href="../pep-0402#the-problem" title="PEP 402 – Simplified Package Layout and Partitioning § The Problem">“The Problem”</a>
section for additional motivations
for namespace packages.  Note that <a class="pep reference internal" href="../pep-0402" title="PEP 402 – Simplified Package Layout and Partitioning">PEP 402</a> has been rejected, but the
motivating use cases are still valid.</p>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">理论依据</a></h2>
<p>目前对命名空间包的命令式方法导致了提供命名空间包的多种稍微不兼容的机制。例如，pkgutil 支持 <code class="docutils literal notranslate"><span class="pre">*.pkg</span></code> 文件；setuptools 则不支持。同样，setuptools 支持检查 zip 文件，并支持向其 <code class="docutils literal notranslate"><span class="pre">_namespace_packages</span></code> 变量添加部分内容，而 pkgutil 不支持。</p>
<p>命名空间包被设计为支持在多个目录中分割（因此通过多个 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 条目找到）。在这种配置下，如果多个部分都提供了一个 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 文件，这并不重要，只要每个部分都正确地初始化了命名空间包。然而，Linux 发行商（包括其他人）更喜欢将独立的部分结合起来，并将它们全部安装到 <em>相同的</em> 文件系统目录中。这就产生了潜在的冲突，因为这些部分现在正试图在目标系统上提供 <em>相同的</em> 文件 – 这是许多软件包管理器所不允许的。允许隐式命名空间包意味着可以完全放弃提供 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 文件的要求，受影响的部分可以安装到一个共同的目录中，或者按照发行版的要求分割到多个目录中。</p>
<p>一个命名空间包不会受到固定的 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 的约束，在命名空间包创建时从父路径计算出来。考虑一下标准库的 <code class="docutils literal notranslate"><span class="pre">encodings</span></code> 包：</p>
<ol class="arabic simple">
<li>假设 <code class="docutils literal notranslate"><span class="pre">encodings</span></code> 成为一个命名空间包。</li>
<li>它有时会在解释器启动时被导入，以初始化标准 io 流。</li>
<li>一个应用程序在启动后修改了 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>，并希望从新的路径条目中贡献额外的编码。</li>
<li>试图从 <code class="docutils literal notranslate"><span class="pre">encodings</span></code> 部分导入编码，该部分在步骤 3 中添加的路径条目中发现。</li>
</ol>
<p>如果导入系统被限制为只能沿着 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 的值寻找在创建 <code class="docutils literal notranslate"><span class="pre">encodings</span></code> 命名空间包时存在的部分，那么在步骤 3 中添加的额外路径将永远不会被搜索到步骤 4 中导入的额外部分。此外，如果步骤 2 有时被跳过（由于某些运行时标志或其他条件），那么在步骤 3 中添加的路径项确实会在第一次导入部分时被使用。因此，本 PEP 要求在每个部分被加载时动态地计算路径项的列表。预计导入机制将通过缓存 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 值来有效地完成这一工作，并且只有在检测到父路径发生变化时才刷新它们。对于像 <code class="docutils literal notranslate"><span class="pre">encodings</span></code> 这样的顶级包来说，这个父路径就是 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>。</p>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">规格</a></h2>
<p>常规软件包将继续有一个 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>，并驻留在一个目录中。</p>
<p>命名空间包不能包含一个 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>。因此，<code class="docutils literal notranslate"><span class="pre">pkgutil.extend_path</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pkg_resources.declare_namespace</span></code> 对于创建命名空间包来说已经过时了。将不会有用于指定命名空间包的标记文件或目录。</p>
<p>在导入处理过程中，导入机制将继续遍历父路径中的每个目录，就像在 Python 3.2 中那样。在寻找名为 “foo” 的模块或包时，对于父路径中的每个目录：</p>
<ul class="simple">
<li>如果找到 <code class="docutils literal notranslate"><span class="pre">&lt;directory&gt;/foo/__init__.py</span></code>，就会导入并返回一个常规包。</li>
<li>如果没有，但找到了 <code class="docutils literal notranslate"><span class="pre">&lt;directory&gt;/foo.{py,pyc,so,pyd}</span></code>，则会导入一个模块并返回。确切的扩展列表因平台和是否指定 -O 标志而不同。这里的列表是有代表性的。</li>
<li>如果没有，但找到了 <code class="docutils literal notranslate"><span class="pre">&lt;directory&gt;/foo</span></code>，并且是一个目录，就会被记录下来，然后继续扫描父路径中的下一个目录。</li>
<li>否则将继续扫描父路径中的下一个目录。</li>
</ul>
<p>如果扫描完成后没有返回一个模块或包，并且至少有一个目录被记录，那么就会创建一个命名空间包。新的命名空间包：</p>
<ul class="simple">
<li>有一个 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 属性，设置为在扫描过程中发现并记录的路径字符串是可迭代的。</li>
<li>没有 <code class="docutils literal notranslate"><span class="pre">__file__</span></code> 属性。</li>
</ul>
<p>注意，如果执行了 “import foo”，并且发现 “foo” 是一个命名空间包（使用上述规则），那么 “foo” 会立即被创建为一个包。命名空间包的创建不会被推迟到子级导入发生时。</p>
<p>命名空间包与常规包没有本质上的区别。它只是创建包的一种不同方式。一旦创建了命名空间包，它和常规包之间就没有功能上的区别。</p>
<section id="dynamic-path-computation">
<h3><a class="toc-backref" href="#dynamic-path-computation" role="doc-backlink">动态路径的计算</a></h3>
<p>导入机制将表现为命名空间包的 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 在每个部分被加载之前被重新计算。</p>
<p>出于性能方面的考虑，预计这将通过检测父路径的变化来实现。如果没有发生变化，那么就不需要对 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 重新进行计算。实现必须确保检测到父路径内容的变化，以及检测到用新的路径入口列表对象替换父路径。</p>
</section>
<section id="impact-on-import-finders-and-loaders">
<h3><a class="toc-backref" href="#impact-on-import-finders-and-loaders" role="doc-backlink">对 import 发现器与加载器的影响</a></h3>
<p><a class="pep reference internal" href="../pep-0302" title="PEP 302 – New Import Hooks">PEP 302</a> defines “finders” that are called to search path elements.
These finders’ <code class="docutils literal notranslate"><span class="pre">find_module</span></code> methods return either a “loader” object
or <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>For a finder to contribute to namespace packages, it must implement a
new <code class="docutils literal notranslate"><span class="pre">find_loader(fullname)</span></code> method.  <code class="docutils literal notranslate"><span class="pre">fullname</span></code> has the same
meaning as for <code class="docutils literal notranslate"><span class="pre">find_module</span></code>.  <code class="docutils literal notranslate"><span class="pre">find_loader</span></code> always returns a
2-tuple of <code class="docutils literal notranslate"><span class="pre">(loader,</span> <span class="pre">&lt;iterable-of-path-entries&gt;)</span></code>.  <code class="docutils literal notranslate"><span class="pre">loader</span></code> may
be <code class="docutils literal notranslate"><span class="pre">None</span></code>, in which case <code class="docutils literal notranslate"><span class="pre">&lt;iterable-of-path-entries&gt;</span></code> (which may
be empty) is added to the list of recorded path entries and path
searching continues.  If <code class="docutils literal notranslate"><span class="pre">loader</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, it is immediately
used to load a module or regular package.</p>
<p>Even if <code class="docutils literal notranslate"><span class="pre">loader</span></code> is returned and is not <code class="docutils literal notranslate"><span class="pre">None</span></code>,
<code class="docutils literal notranslate"><span class="pre">&lt;iterable-of-path-entries&gt;</span></code> must still contain the path entries for
the package.  This allows code such as <code class="docutils literal notranslate"><span class="pre">pkgutil.extend_path()</span></code> to
compute path entries for packages that it does not load.</p>
<p>Note that multiple path entries per finder are allowed.  This is to
support the case where a finder discovers multiple namespace portions
for a given <code class="docutils literal notranslate"><span class="pre">fullname</span></code>.  Many finders will support only a single
namespace package portion per <code class="docutils literal notranslate"><span class="pre">find_loader</span></code> call, in which case this
iterable will contain only a single string.</p>
<p>The import machinery will call <code class="docutils literal notranslate"><span class="pre">find_loader</span></code> if it exists, else fall
back to <code class="docutils literal notranslate"><span class="pre">find_module</span></code>.  Legacy finders which implement
<code class="docutils literal notranslate"><span class="pre">find_module</span></code> but not <code class="docutils literal notranslate"><span class="pre">find_loader</span></code> will be unable to contribute
portions to a namespace package.</p>
<p>The specification expands <a class="pep reference internal" href="../pep-0302" title="PEP 302 – New Import Hooks">PEP 302</a> loaders to include an optional method called
<code class="docutils literal notranslate"><span class="pre">module_repr()</span></code> which if present, is used to generate module object reprs.
See the section below for further details.</p>
</section>
<section id="differences-between-namespace-packages-and-regular-packages">
<h3><a class="toc-backref" href="#differences-between-namespace-packages-and-regular-packages" role="doc-backlink">Differences between namespace packages and regular packages</a></h3>
<p>Namespace packages and regular packages are very similar. The
differences are:</p>
<ul class="simple">
<li>Portions of namespace packages need not all come from the same
directory structure, or even from the same loader. Regular packages
are self-contained: all parts live in the same directory hierarchy.</li>
<li>Namespace packages have no <code class="docutils literal notranslate"><span class="pre">__file__</span></code> attribute.</li>
<li>Namespace packages’ <code class="docutils literal notranslate"><span class="pre">__path__</span></code> attribute is a read-only iterable
of strings, which is automatically updated when the parent path is
modified.</li>
<li>Namespace packages have no <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> module.</li>
<li>Namespace packages have a different type of object for their
<code class="docutils literal notranslate"><span class="pre">__loader__</span></code> attribute.</li>
</ul>
</section>
<section id="namespace-packages-in-the-standard-library">
<h3><a class="toc-backref" href="#namespace-packages-in-the-standard-library" role="doc-backlink">Namespace packages in the standard library</a></h3>
<p>It is possible, and this PEP explicitly allows, that parts of the
standard library be implemented as namespace packages.  When and if
any standard library packages become namespace packages is outside the
scope of this PEP.</p>
</section>
<section id="migrating-from-legacy-namespace-packages">
<h3><a class="toc-backref" href="#migrating-from-legacy-namespace-packages" role="doc-backlink">Migrating from legacy namespace packages</a></h3>
<p>As described above, prior to this PEP <code class="docutils literal notranslate"><span class="pre">pkgutil.extend_path()</span></code> was
used by legacy portions to create namespace packages.  Because it is
likely not practical for all existing portions of a namespace package
to be migrated to this PEP at once, <code class="docutils literal notranslate"><span class="pre">extend_path()</span></code> will be modified
to also recognize <a class="pep reference internal" href="../pep-0420" title="PEP 420 – Implicit Namespace Packages">PEP 420</a> namespace packages.  This will allow some
portions of a namespace to be legacy portions while others are
migrated to <a class="pep reference internal" href="../pep-0420" title="PEP 420 – Implicit Namespace Packages">PEP 420</a>.  These hybrid namespace packages will not have
the dynamic path computation that normal namespace packages have,
since <code class="docutils literal notranslate"><span class="pre">extend_path()</span></code> never provided this functionality in the past.</p>
</section>
</section>
<section id="packaging-implications">
<h2><a class="toc-backref" href="#packaging-implications" role="doc-backlink">Packaging Implications</a></h2>
<p>Multiple portions of a namespace package can be installed into the
same directory, or into separate directories.  For this section,
suppose there are two portions which define “foo.bar” and “foo.baz”.
“foo” itself is a namespace package.</p>
<p>If these are installed in the same location, a single directory “foo”
would be in a directory that is on <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>.  Inside “foo” would
be two directories, “bar” and “baz”.  If “foo.bar” is removed (perhaps
by an OS package manager), care must be taken not to remove the
“foo/baz” or “foo” directories.  Note that in this case “foo” will be
a namespace package (because it lacks an <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>), even though
all of its portions are in the same directory.</p>
<p>Note that “foo.bar” and “foo.baz” can be installed into the same “foo”
directory because they will not have any files in common.</p>
<p>If the portions are installed in different locations, two different
“foo” directories would be in directories that are on <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>.
“foo/bar” would be in one of these sys.path entries, and “foo/baz”
would be in the other.  Upon removal of “foo.bar”, the “foo/bar” and
corresponding “foo” directories can be completely removed.  But
“foo/baz” and its corresponding “foo” directory cannot be removed.</p>
<p>It is also possible to have the “foo.bar” portion installed in a
directory on <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>, and have the “foo.baz” portion provided in
a zip file, also on <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>.</p>
</section>
<section id="examples">
<h2><a class="toc-backref" href="#examples" role="doc-backlink">示例</a></h2>
<section id="nested-namespace-packages">
<h3><a class="toc-backref" href="#nested-namespace-packages" role="doc-backlink">嵌套的命名空间包</a></h3>
<p>这个例子使用了以下目录结构</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Lib</span><span class="o">/</span><span class="n">test</span><span class="o">/</span><span class="n">namespace_pkgs</span>
    <span class="n">project1</span>
        <span class="n">parent</span>
            <span class="n">child</span>
                <span class="n">one</span><span class="o">.</span><span class="n">py</span>
    <span class="n">project2</span>
        <span class="n">parent</span>
            <span class="n">child</span>
                <span class="n">two</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>这里，父代和子代都是命名空间包。它们的 portion 存在于不同的目录中，并且它们没有 <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 文件。</p>
<p>这里我们将父目录添加到 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 中，并显示 portion 被正确找到</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;Lib/test/namespace_pkgs/project1&#39;</span><span class="p">,</span> <span class="s1">&#39;Lib/test/namespace_pkgs/project2&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">parent.child.one</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parent</span><span class="o">.</span><span class="n">__path__</span>
<span class="go">_NamespacePath([&#39;Lib/test/namespace_pkgs/project1/parent&#39;, &#39;Lib/test/namespace_pkgs/project2/parent&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parent</span><span class="o">.</span><span class="n">child</span><span class="o">.</span><span class="n">__path__</span>
<span class="go">_NamespacePath([&#39;Lib/test/namespace_pkgs/project1/parent/child&#39;, &#39;Lib/test/namespace_pkgs/project2/parent/child&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">parent.child.two</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="id2">
<h3><a class="toc-backref" href="#id2" role="doc-backlink">动态路径的计算</a></h3>
<p>这个例子使用类似的目录结构，但增加了第三个部分</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Lib</span><span class="o">/</span><span class="n">test</span><span class="o">/</span><span class="n">namespace_pkgs</span>
    <span class="n">project1</span>
        <span class="n">parent</span>
            <span class="n">child</span>
                <span class="n">one</span><span class="o">.</span><span class="n">py</span>
    <span class="n">project2</span>
        <span class="n">parent</span>
            <span class="n">child</span>
                <span class="n">two</span><span class="o">.</span><span class="n">py</span>
    <span class="n">project3</span>
        <span class="n">parent</span>
            <span class="n">child</span>
                <span class="n">three</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>我们在 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 中添加 <code class="docutils literal notranslate"><span class="pre">project1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">project2</span></code>，然后导入 <code class="docutils literal notranslate"><span class="pre">parent.child.one</span></code> 和 <code class="docutils literal notranslate"><span class="pre">parent.child.two</span></code>。然后我们在 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 中加入 <code class="docutils literal notranslate"><span class="pre">project3</span></code>，当 <code class="docutils literal notranslate"><span class="pre">parent.child.three</span></code> 被导入时，<code class="docutils literal notranslate"><span class="pre">project3/parent</span></code> 被自动添加到 <code class="docutils literal notranslate"><span class="pre">parent.__path__</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># add the first two parent paths to sys.path</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">sys</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">path</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;Lib/test/namespace_pkgs/project1&#39;</span><span class="p">,</span> <span class="s1">&#39;Lib/test/namespace_pkgs/project2&#39;</span><span class="p">]</span>

<span class="c1"># parent.child.one can be imported, because project1 was added to sys.path:</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">parent.child.one</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">parent</span><span class="o">.</span><span class="n">__path__</span>
<span class="n">_NamespacePath</span><span class="p">([</span><span class="s1">&#39;Lib/test/namespace_pkgs/project1/parent&#39;</span><span class="p">,</span> <span class="s1">&#39;Lib/test/namespace_pkgs/project2/parent&#39;</span><span class="p">])</span>

<span class="c1"># parent.child.__path__ contains project1/parent/child and project2/parent/child, but not project3/parent/child:</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">parent</span><span class="o">.</span><span class="n">child</span><span class="o">.</span><span class="n">__path__</span>
<span class="n">_NamespacePath</span><span class="p">([</span><span class="s1">&#39;Lib/test/namespace_pkgs/project1/parent/child&#39;</span><span class="p">,</span> <span class="s1">&#39;Lib/test/namespace_pkgs/project2/parent/child&#39;</span><span class="p">])</span>

<span class="c1"># parent.child.two can be imported, because project2 was added to sys.path:</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">parent.child.two</span>

<span class="c1"># we cannot import parent.child.three, because project3 is not in the path:</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">parent.child.three</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
  <span class="n">File</span> <span class="s2">&quot;&lt;frozen importlib._bootstrap&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1286</span><span class="p">,</span> <span class="ow">in</span> <span class="n">_find_and_load</span>
  <span class="n">File</span> <span class="s2">&quot;&lt;frozen importlib._bootstrap&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1250</span><span class="p">,</span> <span class="ow">in</span> <span class="n">_find_and_load_unlocked</span>
<span class="ne">ImportError</span><span class="p">:</span> <span class="n">No</span> <span class="n">module</span> <span class="n">named</span> <span class="s1">&#39;parent.child.three&#39;</span>

<span class="c1"># now add project3 to sys.path:</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Lib/test/namespace_pkgs/project3&#39;</span><span class="p">)</span>

<span class="c1"># and now parent.child.three can be imported:</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">parent.child.three</span>

<span class="c1"># project3/parent has been added to parent.__path__:</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">parent</span><span class="o">.</span><span class="n">__path__</span>
<span class="n">_NamespacePath</span><span class="p">([</span><span class="s1">&#39;Lib/test/namespace_pkgs/project1/parent&#39;</span><span class="p">,</span> <span class="s1">&#39;Lib/test/namespace_pkgs/project2/parent&#39;</span><span class="p">,</span> <span class="s1">&#39;Lib/test/namespace_pkgs/project3/parent&#39;</span><span class="p">])</span>

<span class="c1"># and project3/parent/child has been added to parent.child.__path__</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">parent</span><span class="o">.</span><span class="n">child</span><span class="o">.</span><span class="n">__path__</span>
<span class="n">_NamespacePath</span><span class="p">([</span><span class="s1">&#39;Lib/test/namespace_pkgs/project1/parent/child&#39;</span><span class="p">,</span> <span class="s1">&#39;Lib/test/namespace_pkgs/project2/parent/child&#39;</span><span class="p">,</span> <span class="s1">&#39;Lib/test/namespace_pkgs/project3/parent/child&#39;</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
</section>
<section id="discussion">
<h2><a class="toc-backref" href="#discussion" role="doc-backlink">讨论</a></h2>
<p>At PyCon 2012, we had a discussion about namespace packages at which
<a class="pep reference internal" href="../pep-0382" title="PEP 382 – Namespace Packages">PEP 382</a> and <a class="pep reference internal" href="../pep-0402" title="PEP 402 – Simplified Package Layout and Partitioning">PEP 402</a> were rejected, to be replaced by this PEP <a class="footnote-reference brackets" href="#id12" id="id3">[3]</a>.</p>
<p>没有打算取消对常规包的支持。如果开发者知道其包永远不会成为命名空间包的一部分，那么它作为一个普通的包（有一个 <code class="docutils literal notranslate"><span class="pre">init__.py</span></code>）会有性能上的优势。当一个常规包位于路径上时，它的创建和加载可以立即进行。对于命名空间包，在创建包之前，必须对路径中的所有条目进行扫描。</p>
<p>注意，如果一个目录没有 <code class="docutils literal notranslate"><span class="pre">init__.py</span></code> 文件，将不再引发 ImportWarning。这样的目录现在将作为一个命名空间包被导入，而在之前的 Python 版本中，导入警告将被触发。</p>
<p>Nick Coghlan 提出了他对这一建议的反对意见清单 <a class="footnote-reference brackets" href="#id13" id="id4">[4]</a>。它们是：</p>
<ol class="arabic simple">
<li>Implicit package directories go against the Zen of Python.</li>
<li>Implicit package directories pose awkward backwards compatibility
challenges.</li>
<li>Implicit package directories introduce ambiguity into file system
layouts.</li>
<li>Implicit package directories will permanently entrench current
newbie-hostile behavior in <code class="docutils literal notranslate"><span class="pre">__main__</span></code>.</li>
</ol>
<p>Nick later gave a detailed response to his own objections <a class="footnote-reference brackets" href="#id14" id="id5">[5]</a>, which
is summarized here:</p>
<ol class="arabic simple">
<li>The practicality of this PEP wins over other proposals and the
status quo.</li>
<li>Minor backward compatibility issues are okay, as long as they are
properly documented.</li>
<li>This will be addressed in <a class="pep reference internal" href="../pep-0395" title="PEP 395 – Qualified Names for Modules">PEP 395</a>.</li>
<li>This will also be addressed in <a class="pep reference internal" href="../pep-0395" title="PEP 395 – Qualified Names for Modules">PEP 395</a>.</li>
</ol>
<p>The inclusion of namespace packages in the standard library was
motivated by Martin v. Löwis, who wanted the <code class="docutils literal notranslate"><span class="pre">encodings</span></code> package to
become a namespace package <a class="footnote-reference brackets" href="#id15" id="id6">[6]</a>.  While this PEP allows for standard
library packages to become namespaces, it defers a decision on
<code class="docutils literal notranslate"><span class="pre">encodings</span></code>.</p>
<section id="find-module-versus-find-loader">
<h3><a class="toc-backref" href="#find-module-versus-find-loader" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">find_module</span></code> versus <code class="docutils literal notranslate"><span class="pre">find_loader</span></code></a></h3>
<p>An early draft of this PEP specified a change to the <code class="docutils literal notranslate"><span class="pre">find_module</span></code>
method in order to support namespace packages.  It would be modified
to return a string in the case where a namespace package portion was
discovered.</p>
<p>However, this caused a problem with existing code outside of the
standard library which calls <code class="docutils literal notranslate"><span class="pre">find_module</span></code>.  Because this code would
not be upgraded in concert with changes required by this PEP, it would
fail when it would receive unexpected return values from
<code class="docutils literal notranslate"><span class="pre">find_module</span></code>.  Because of this incompatibility, this PEP now
specifies that finders that want to provide namespace portions must
implement the <code class="docutils literal notranslate"><span class="pre">find_loader</span></code> method, described above.</p>
<p>The use case for supporting multiple portions per <code class="docutils literal notranslate"><span class="pre">find_loader</span></code> call
is given in <a class="footnote-reference brackets" href="#id16" id="id7">[7]</a>.</p>
</section>
<section id="id8">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">动态路径的计算</a></h3>
<p>Guido raised a concern that automatic dynamic path computation was an
unnecessary feature <a class="footnote-reference brackets" href="#id17" id="id9">[8]</a>.  Later in that thread, PJ Eby and Nick
Coghlan presented arguments as to why dynamic computation would
minimize surprise to Python users.  The conclusion of that discussion
has been included in this PEP’s Rationale section.</p>
<p>An earlier version of this PEP required that dynamic path computation
could only take affect if the parent path object were modified
in-place.  That is, this would work:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;new-dir&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>But this would not:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sys</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;new-dir&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>In the same thread <a class="footnote-reference brackets" href="#id17" id="id10">[8]</a>, it was pointed out that this restriction is
not required.  If the parent path is looked up by name instead of by
holding a reference to it, then there is no restriction on how the
parent path is modified or replaced.  For a top-level namespace
package, the lookup would be the module named <code class="docutils literal notranslate"><span class="pre">&quot;sys&quot;</span></code> then its
attribute <code class="docutils literal notranslate"><span class="pre">&quot;path&quot;</span></code>.  For a namespace package nested inside a package
<code class="docutils literal notranslate"><span class="pre">foo</span></code>, the lookup would be for the module named <code class="docutils literal notranslate"><span class="pre">&quot;foo&quot;</span></code> then its
attribute <code class="docutils literal notranslate"><span class="pre">&quot;__path__&quot;</span></code>.</p>
</section>
</section>
<section id="module-reprs">
<h2><a class="toc-backref" href="#module-reprs" role="doc-backlink">Module reprs</a></h2>
<p>Previously, module reprs were hard coded based on assumptions about a module’s
<code class="docutils literal notranslate"><span class="pre">__file__</span></code> attribute.  If this attribute existed and was a string, it was
assumed to be a file system path, and the module object’s repr would include
this in its value.  The only exception was that <a class="pep reference internal" href="../pep-0302" title="PEP 302 – New Import Hooks">PEP 302</a> reserved missing
<code class="docutils literal notranslate"><span class="pre">__file__</span></code> attributes to built-in modules, and in CPython, this assumption
was baked into the module object’s implementation.  Because of this
restriction, some modules contained contrived <code class="docutils literal notranslate"><span class="pre">__file__</span></code> values that did not
reflect file system paths, and which could cause unexpected problems later
(e.g. <code class="docutils literal notranslate"><span class="pre">os.path.join()</span></code> on a non-path <code class="docutils literal notranslate"><span class="pre">__file__</span></code> would return gibberish).</p>
<p>This PEP relaxes this constraint, and leaves the setting of <code class="docutils literal notranslate"><span class="pre">__file__</span></code> to
the purview of the loader producing the module.  Loaders may opt to leave
<code class="docutils literal notranslate"><span class="pre">__file__</span></code> unset if no file system path is appropriate.  Loaders may also
set additional reserved attributes on the module if useful.  This means that
the definitive way to determine the origin of a module is to check its
<code class="docutils literal notranslate"><span class="pre">__loader__</span></code> attribute.</p>
<p>For example, namespace packages as described in this PEP will have no
<code class="docutils literal notranslate"><span class="pre">__file__</span></code> attribute because no corresponding file exists.  In order to
provide flexibility and descriptiveness in the reprs of such modules, a new
optional protocol is added to <a class="pep reference internal" href="../pep-0302" title="PEP 302 – New Import Hooks">PEP 302</a> loaders.  Loaders can implement a
<code class="docutils literal notranslate"><span class="pre">module_repr()</span></code> method which takes a single argument, the module object.
This method should return the string to be used verbatim as the repr of the
module.  The rules for producing a module repr are now standardized as:</p>
<ul class="simple">
<li>If the module has an <code class="docutils literal notranslate"><span class="pre">__loader__</span></code> and that loader has a <code class="docutils literal notranslate"><span class="pre">module_repr()</span></code>
method, call it with a single argument, which is the module object.  The
value returned is used as the module’s repr.</li>
<li>If an exception occurs in <code class="docutils literal notranslate"><span class="pre">module_repr()</span></code>, the exception is
caught and discarded, and the calculation of the module’s repr
continues as if <code class="docutils literal notranslate"><span class="pre">module_repr()</span></code> did not exist.</li>
<li>If the module has an <code class="docutils literal notranslate"><span class="pre">__file__</span></code> attribute, this is used as part of the
module’s repr.</li>
<li>If the module has no <code class="docutils literal notranslate"><span class="pre">__file__</span></code> but does have an <code class="docutils literal notranslate"><span class="pre">__loader__</span></code>, then the
loader’s repr is used as part of the module’s repr.</li>
<li>Otherwise, just use the module’s <code class="docutils literal notranslate"><span class="pre">__name__</span></code> in the repr.</li>
</ul>
<p>Here is a snippet showing how namespace module reprs are calculated
from its loader:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NamespaceLoader</span><span class="p">:</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">module_repr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">module</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;module &#39;</span><span class="si">{}</span><span class="s2">&#39; (namespace)&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
</pre></div>
</div>
<p>Built-in module reprs would no longer need to be hard-coded, but
instead would come from their loader as well:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BuiltinImporter</span><span class="p">:</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">module_repr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">module</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;module &#39;</span><span class="si">{}</span><span class="s2">&#39; (built-in)&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
</pre></div>
</div>
<p>Here are some example reprs of different types of modules with
different sets of the related attributes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">email</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">email</span>
<span class="go">&lt;module &#39;email&#39; from &#39;/home/barry/projects/python/pep-420/Lib/email/__init__.py&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">email</span><span class="p">)(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">&lt;module &#39;foo&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="vm">__file__</span> <span class="o">=</span> <span class="s1">&#39;zippy:/de/do/dah&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">&lt;module &#39;foo&#39; from &#39;zippy:/de/do/dah&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Loader</span><span class="p">:</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">__loader__</span> <span class="o">=</span> <span class="n">Loader</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">m</span><span class="o">.</span><span class="vm">__file__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">&lt;module &#39;foo&#39; (&lt;class &#39;__main__.Loader&#39;&gt;)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">NewLoader</span><span class="p">:</span>
<span class="gp">... </span>  <span class="nd">@classmethod</span>
<span class="gp">... </span>  <span class="k">def</span> <span class="nf">module_repr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">module</span><span class="p">):</span>
<span class="gp">... </span>     <span class="k">return</span> <span class="s1">&#39;&lt;mystery module!&gt;&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">__loader__</span> <span class="o">=</span> <span class="n">NewLoader</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">&lt;mystery module!&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="references">
<h2><a class="toc-backref" href="#references" role="doc-backlink">References</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id11" role="note">
<dt class="label" id="id11">[<a href="#id1">1</a>]</dt>
<dd>PEP 420 branch (<a class="reference external" href="http://hg.python.org/features/pep-420">http://hg.python.org/features/pep-420</a>)</aside>
<aside class="footnote brackets" id="id12" role="note">
<dt class="label" id="id12">[<a href="#id3">3</a>]</dt>
<dd>PyCon 2012 Namespace Package discussion outcome
(<a class="reference external" href="https://mail.python.org/pipermail/import-sig/2012-March/000421.html">https://mail.python.org/pipermail/import-sig/2012-March/000421.html</a>)</aside>
<aside class="footnote brackets" id="id13" role="note">
<dt class="label" id="id13">[<a href="#id4">4</a>]</dt>
<dd>Nick Coghlan’s objection to the lack of marker files or directories
(<a class="reference external" href="https://mail.python.org/pipermail/import-sig/2012-March/000423.html">https://mail.python.org/pipermail/import-sig/2012-March/000423.html</a>)</aside>
<aside class="footnote brackets" id="id14" role="note">
<dt class="label" id="id14">[<a href="#id5">5</a>]</dt>
<dd>Nick Coghlan’s response to his initial objections
(<a class="reference external" href="https://mail.python.org/pipermail/import-sig/2012-April/000464.html">https://mail.python.org/pipermail/import-sig/2012-April/000464.html</a>)</aside>
<aside class="footnote brackets" id="id15" role="note">
<dt class="label" id="id15">[<a href="#id6">6</a>]</dt>
<dd>Martin v. Löwis’s suggestion to make <code class="docutils literal notranslate"><span class="pre">encodings</span></code> a namespace
package
(<a class="reference external" href="https://mail.python.org/pipermail/import-sig/2012-May/000540.html">https://mail.python.org/pipermail/import-sig/2012-May/000540.html</a>)</aside>
<aside class="footnote brackets" id="id16" role="note">
<dt class="label" id="id16">[<a href="#id7">7</a>]</dt>
<dd>Use case for multiple portions per <code class="docutils literal notranslate"><span class="pre">find_loader</span></code> call
(<a class="reference external" href="https://mail.python.org/pipermail/import-sig/2012-May/000585.html">https://mail.python.org/pipermail/import-sig/2012-May/000585.html</a>)</aside>
<aside class="footnote brackets" id="id17" role="note">
<dt class="label" id="id17">[8]<em> (<a href='#id9'>1</a>, <a href='#id10'>2</a>) </em></dt>
<dd>Discussion about dynamic path computation
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2012-May/119560.html">https://mail.python.org/pipermail/python-dev/2012-May/119560.html</a>)</aside>
</aside>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document has been placed in the public domain.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/pep-0420.txt">https://github.com/python/peps/blob/main/pep-0420.txt</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/pep-0420.txt">2022-01-21 11:03:51 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">摘要</a></li>
<li><a class="reference internal" href="#terminology">术语</a></li>
<li><a class="reference internal" href="#namespace-packages-today">今天的命名空间包</a></li>
<li><a class="reference internal" href="#rationale">理论依据</a></li>
<li><a class="reference internal" href="#specification">规格</a><ul>
<li><a class="reference internal" href="#dynamic-path-computation">动态路径的计算</a></li>
<li><a class="reference internal" href="#impact-on-import-finders-and-loaders">对 import 发现器与加载器的影响</a></li>
<li><a class="reference internal" href="#differences-between-namespace-packages-and-regular-packages">Differences between namespace packages and regular packages</a></li>
<li><a class="reference internal" href="#namespace-packages-in-the-standard-library">Namespace packages in the standard library</a></li>
<li><a class="reference internal" href="#migrating-from-legacy-namespace-packages">Migrating from legacy namespace packages</a></li>
</ul>
</li>
<li><a class="reference internal" href="#packaging-implications">Packaging Implications</a></li>
<li><a class="reference internal" href="#examples">示例</a><ul>
<li><a class="reference internal" href="#nested-namespace-packages">嵌套的命名空间包</a></li>
<li><a class="reference internal" href="#id2">动态路径的计算</a></li>
</ul>
</li>
<li><a class="reference internal" href="#discussion">讨论</a><ul>
<li><a class="reference internal" href="#find-module-versus-find-loader"><code class="docutils literal notranslate"><span class="pre">find_module</span></code> versus <code class="docutils literal notranslate"><span class="pre">find_loader</span></code></a></li>
<li><a class="reference internal" href="#id8">动态路径的计算</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-reprs">Module reprs</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/pep-0420.txt">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
</body>
</html>